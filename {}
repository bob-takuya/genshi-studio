import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App'
import './styles/index.css'

// Register service worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/genshi-studio/sw.js', {
        scope: '/genshi-studio/'
      })
      
      console.log('Service Worker registered successfully:', registration)
      
      // Wait for the service worker to be ready and controlling the page
      await navigator.serviceWorker.ready
      console.log('Service Worker is ready and controlling the page')
      
      // Listen for updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing
        if (newWorker) {
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New version available
              console.log('New app version available')
            }
          })
        }
      })
      
      // Handle controller change (when SW takes control)
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        console.log('Service Worker controller changed')
      })
    } catch (error) {
      console.error('Service Worker registration failed:', error)
    }
  })
}

// Create root element and render the app
ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter basename="/genshi-studio">
      <App />
    </BrowserRouter>
  </React.StrictMode>
)
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  X, 
  Save, 
  Play, 
  Pause, 
  RotateCcw, 
  Share2, 
  Download, 
  Plus,
  Layers,
  Palette
} from 'lucide-react';
import { 
  CustomPattern, 
  PatternParameterConfig, 
  AnimationConfig, 
  PatternCombination,
  Color,
  PatternGeneratorOptions
} from '../../types/graphics';
import { AdvancedPatternGenerator } from '../../graphics/patterns/AdvancedPatternGenerator';
import { PatternType } from '../../graphics/patterns/CulturalPatternGenerator';
import { PatternStorageService } from '../../services/PatternStorageService';

interface PatternBuilderProps {
  isOpen: boolean;
  onClose: () => void;
  initialPattern?: CustomPattern;
  onSave?: (pattern: CustomPattern) => void;
}

export function PatternBuilder({ isOpen, onClose, initialPattern, onSave }: PatternBuilderProps) {
  const [activeTab, setActiveTab] = useState<'design' | 'animate' | 'combine'>('design');
  const [currentPattern, setCurrentPattern] = useState<CustomPattern | null>(initialPattern || null);
  const [isAnimating, setIsAnimating] = useState(false);
  const [animationConfig, setAnimationConfig] = useState<AnimationConfig>({
    enabled: false,
    duration: 2,
    direction: 'forward',
    easing: 'ease',
    animatedParams: ['rotation'],
    keyframes: [
      { time: 0, parameters: { rotation: 0 } },
      { time: 1, parameters: { rotation: 360 } }
    ]
  });
  const [patternCombination, setPatternCombination] = useState<PatternCombination>({
    id: crypto.randomUUID(),
    patterns: [],
    compositionMode: 'overlay'
  });
  const [selectedBasePattern, setSelectedBasePattern] = useState<PatternType>(PatternType.Ichimatsu);
  const [patternParameters, setPatternParameters] = useState<PatternParameterConfig[]>([]);
  const [previewSize, setPreviewSize] = useState({ width: 400, height: 400 });
  
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const generatorRef = useRef<AdvancedPatternGenerator | null>(null);

  // Initialize pattern generator
  useEffect(() => {
    if (!generatorRef.current) {
      generatorRef.current = new AdvancedPatternGenerator();
    }
    
    return () => {
      if (generatorRef.current) {
        generatorRef.current.destroy();
      }
    };
  }, []);

  // Initialize default parameters
  useEffect(() => {
    if (!currentPattern) {
      setPatternParameters(getDefaultParameters(selectedBasePattern));
    } else {
      setPatternParameters(currentPattern.parameters);
      setSelectedBasePattern(currentPattern.basePattern as PatternType);
    }
  }, [selectedBasePattern, currentPattern]);

  // Update preview when parameters change
  useEffect(() => {
    updatePreview();
  }, [patternParameters, selectedBasePattern, previewSize]);

  const updatePreview = useCallback(() => {
    if (!generatorRef.current || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = previewSize.width;
    canvas.height = previewSize.height;

    const options = buildOptionsFromParameters(patternParameters);
    const imageData = generatorRef.current.generatePattern(
      selectedBasePattern,
      previewSize.width,
      previewSize.height,
      options
    );

    ctx.putImageData(imageData, 0, 0);
  }, [patternParameters, selectedBasePattern, previewSize]);

  const buildOptionsFromParameters = (params: PatternParameterConfig[]): PatternGeneratorOptions => {
    const options: PatternGeneratorOptions = {
      scale: 1,
      rotation: 0,
      color1: { r: 0, g: 0, b: 0, a: 1 },
      color2: { r: 1, g: 1, b: 1, a: 1 }
    };

    params.forEach(param => {
      if (param.type === 'color') {
        const hex = param.value as string;
        (options as any)[param.name] = hexToColor(hex);
      } else {
        (options as any)[param.name] = param.value;
      }
    });

    return options;
  };

  const hexToColor = (hex: string): Color => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) return { r: 0, g: 0, b: 0, a: 1 };
    
    return {
      r: parseInt(result[1], 16) / 255,
      g: parseInt(result[2], 16) / 255,
      b: parseInt(result[3], 16) / 255,
      a: 1
    };
  };


  const handleParameterChange = (paramName: string, value: any) => {
    setPatternParameters(prev => 
      prev.map(param => 
        param.name === paramName 
          ? { ...param, value }
          : param
      )
    );
  };

  const startAnimation = () => {
    if (!generatorRef.current || !canvasRef.current) return;

    setIsAnimating(true);
    
    generatorRef.current.generateAnimatedPattern(
      selectedBasePattern,
      previewSize.width,
      previewSize.height,
      buildOptionsFromParameters(patternParameters),
      animationConfig,
      (imageData) => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        ctx.putImageData(imageData, 0, 0);
      }
    );
  };

  const stopAnimation = () => {
    setIsAnimating(false);
    if (generatorRef.current) {
      generatorRef.current.stopAnimation();
    }
    updatePreview();
  };

  const savePattern = () => {
    const pattern: CustomPattern = {
      id: currentPattern?.id || crypto.randomUUID(),
      name: currentPattern?.name || `Custom ${selectedBasePattern}`,
      description: currentPattern?.description || 'Custom pattern created in Pattern Builder',
      basePattern: selectedBasePattern,
      parameters: patternParameters,
      animation: animationConfig.enabled ? animationConfig : undefined,
      combinations: patternCombination.patterns.length > 0 ? [patternCombination] : undefined,
      createdAt: currentPattern?.createdAt || new Date(),
      modifiedAt: new Date(),
      tags: currentPattern?.tags || ['custom'],
      isPublic: currentPattern?.isPublic || false
    };

    PatternStorageService.savePattern(pattern);
    setCurrentPattern(pattern);
    
    if (onSave) {
      onSave(pattern);
    }
  };

  const sharePattern = () => {
    if (!currentPattern) return;
    
    const shareUrl = PatternStorageService.generateShareableUrl(currentPattern);
    navigator.clipboard.writeText(shareUrl);
    
    // Show success message (you might want to add a toast notification here)
    console.log('Pattern share URL copied to clipboard:', shareUrl);
  };

  const exportPattern = (format: 'png' | 'svg' | 'json') => {
    if (!currentPattern || !generatorRef.current) return;

    const result = generatorRef.current.exportPattern(
      currentPattern,
      previewSize.width,
      previewSize.height,
      format
    );

    if (result instanceof Promise) {
      result.then(blob => downloadBlob(blob, `pattern.${format}`));
    } else if (typeof result === 'string') {
      downloadText(result, `pattern.${format}`);
    }
  };

  const downloadBlob = (blob: Blob, filename: string) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const downloadText = (text: string, filename: string) => {
    const blob = new Blob([text], { type: 'text/plain' });
    downloadBlob(blob, filename);
  };

  const addParameterToAnimation = (paramName: string) => {
    setAnimationConfig(prev => ({
      ...prev,
      animatedParams: [...prev.animatedParams, paramName]
    }));
  };

  const removeParameterFromAnimation = (paramName: string) => {
    setAnimationConfig(prev => ({
      ...prev,
      animatedParams: prev.animatedParams.filter(p => p !== paramName)
    }));
  };

  const renderParameterControl = (param: PatternParameterConfig) => {
    switch (param.type) {
      case 'range':
        return (
          <div className="flex items-center gap-3">
            <input
              type="range"
              min={param.min || 0}
              max={param.max || 100}
              step={param.step || 1}
              value={param.value as number}
              onChange={(e) => handleParameterChange(param.name, parseFloat(e.target.value))}
              className="flex-1"
            />
            <span className="text-sm w-16 text-right">{param.value}</span>
          </div>
        );
      
      case 'color':
        return (
          <input
            type="color"
            value={param.value as string}
            onChange={(e) => handleParameterChange(param.name, e.target.value)}
            className="w-full h-10 rounded cursor-pointer"
          />
        );
      
      case 'boolean':
        return (
          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={param.value as boolean}
              onChange={(e) => handleParameterChange(param.name, e.target.checked)}
              className="rounded"
            />
            <span>Enabled</span>
          </label>
        );
      
      case 'select':
        return (
          <select
            value={param.value as string}
            onChange={(e) => handleParameterChange(param.name, e.target.value)}
            className="w-full p-2 rounded border border-border bg-background"
          >
            {param.options?.map(option => (
              <option key={option} value={option}>
                {option}
              </option>
            ))}
          </select>
        );
      
      default:
        return (
          <input
            type="text"
            value={param.value as string}
            onChange={(e) => handleParameterChange(param.name, e.target.value)}
            className="w-full p-2 rounded border border-border bg-background"
          />
        );
    }
  };

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
        onClick={(e) => {
          if (e.target === e.currentTarget) onClose();
        }}
      >
        <motion.div
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.9, opacity: 0 }}
          className="bg-card rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] flex flex-col"
        >
          {/* Header */}
          <div className="p-6 border-b border-border flex items-center justify-between">
            <h2 className="text-2xl font-bold">Pattern Builder</h2>
            <div className="flex items-center gap-2">
              <button
                onClick={savePattern}
                className="px-4 py-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors flex items-center gap-2"
              >
                <Save className="h-4 w-4" />
                Save
              </button>
              <button
                onClick={sharePattern}
                className="px-4 py-2 bg-secondary text-secondary-foreground rounded-lg hover:bg-secondary/90 transition-colors flex items-center gap-2"
              >
                <Share2 className="h-4 w-4" />
                Share
              </button>
              <button
                onClick={onClose}
                className="p-2 hover:bg-accent rounded-md transition-colors"
              >
                <X className="h-5 w-5" />
              </button>
            </div>
          </div>

          {/* Tabs */}
          <div className="flex border-b border-border">
            {[
              { id: 'design', label: 'Design', icon: Palette },
              { id: 'animate', label: 'Animate', icon: Play },
              { id: 'combine', label: 'Combine', icon: Layers }
            ].map(tab => (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id as any)}
                className={`flex items-center gap-2 px-6 py-3 text-sm font-medium transition-colors ${
                  activeTab === tab.id
                    ? 'border-b-2 border-primary text-primary bg-primary/10'
                    : 'text-muted-foreground hover:text-foreground'
                }`}
              >
                <tab.icon className="h-4 w-4" />
                {tab.label}
              </button>
            ))}
          </div>

          {/* Content */}
          <div className="flex-1 flex overflow-hidden">
            {/* Controls Panel */}
            <div className="w-1/3 border-r border-border p-6 overflow-y-auto">
              {activeTab === 'design' && (
                <div className="space-y-6">
                  <div>
                    <h3 className="text-lg font-semibold mb-4">Base Pattern</h3>
                    <select
                      value={selectedBasePattern}
                      onChange={(e) => setSelectedBasePattern(e.target.value as PatternType)}
                      className="w-full p-2 rounded border border-border bg-background"
                    >
                      {Object.values(PatternType).map(type => (
                        <option key={type} value={type}>
                          {type.charAt(0).toUpperCase() + type.slice(1)}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div>
                    <h3 className="text-lg font-semibold mb-4">Parameters</h3>
                    <div className="space-y-4">
                      {patternParameters.map((param) => (
                        <div key={param.name}>
                          <div className="flex items-center justify-between mb-2">
                            <label className="text-sm font-medium">
                              {param.name}
                            </label>
                            {activeTab === 'animate' && (
                              <button
                                onClick={() => {
                                  if (animationConfig.animatedParams.includes(param.name)) {
                                    removeParameterFromAnimation(param.name);
                                  } else {
                                    addParameterToAnimation(param.name);
                                  }
                                }}
                                className={`p-1 rounded ${
                                  animationConfig.animatedParams.includes(param.name)
                                    ? 'bg-primary text-primary-foreground'
                                    : 'bg-secondary text-secondary-foreground'
                                }`}
                              >
                                <Play className="h-3 w-3" />
                              </button>
                            )}
                          </div>
                          {renderParameterControl(param)}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              )}

              {activeTab === 'animate' && (
                <div className="space-y-6">
                  <div>
                    <h3 className="text-lg font-semibold mb-4">Animation Settings</h3>
                    
                    <div className="space-y-4">
                      <div>
                        <label className="text-sm font-medium mb-2 block">Duration (seconds)</label>
                        <input
                          type="number"
                          min="0.1"
                          step="0.1"
                          value={animationConfig.duration}
                          onChange={(e) => setAnimationConfig(prev => ({
                            ...prev,
                            duration: parseFloat(e.target.value)
                          }))}
                          className="w-full p-2 rounded border border-border bg-background"
                        />
                      </div>

                      <div>
                        <label className="text-sm font-medium mb-2 block">Direction</label>
                        <select
                          value={animationConfig.direction}
                          onChange={(e) => setAnimationConfig(prev => ({
                            ...prev,
                            direction: e.target.value as any
                          }))}
                          className="w-full p-2 rounded border border-border bg-background"
                        >
                          <option value="forward">Forward</option>
                          <option value="reverse">Reverse</option>
                          <option value="alternate">Alternate</option>
                        </select>
                      </div>

                      <div>
                        <label className="text-sm font-medium mb-2 block">Easing</label>
                        <select
                          value={animationConfig.easing}
                          onChange={(e) => setAnimationConfig(prev => ({
                            ...prev,
                            easing: e.target.value as any
                          }))}
                          className="w-full p-2 rounded border border-border bg-background"
                        >
                          <option value="linear">Linear</option>
                          <option value="ease">Ease</option>
                          <option value="ease-in">Ease In</option>
                          <option value="ease-out">Ease Out</option>
                          <option value="ease-in-out">Ease In Out</option>
                        </select>
                      </div>
                    </div>
                  </div>

                  <div>
                    <h3 className="text-lg font-semibold mb-4">Animation Controls</h3>
                    <div className="flex gap-2">
                      <button
                        onClick={isAnimating ? stopAnimation : startAnimation}
                        className={`flex-1 py-2 rounded flex items-center justify-center gap-2 ${
                          isAnimating
                            ? 'bg-red-500 text-white'
                            : 'bg-green-500 text-white'
                        }`}
                      >
                        {isAnimating ? (
                          <>
                            <Pause className="h-4 w-4" />
                            Stop
                          </>
                        ) : (
                          <>
                            <Play className="h-4 w-4" />
                            Start
                          </>
                        )}
                      </button>
                      <button
                        onClick={() => {
                          stopAnimation();
                          updatePreview();
                        }}
                        className="px-4 py-2 bg-secondary text-secondary-foreground rounded flex items-center gap-2"
                      >
                        <RotateCcw className="h-4 w-4" />
                        Reset
                      </button>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === 'combine' && (
                <div className="space-y-6">
                  <div>
                    <h3 className="text-lg font-semibold mb-4">Pattern Combination</h3>
                    <p className="text-sm text-muted-foreground mb-4">
                      Add multiple patterns to create complex compositions
                    </p>
                    
                    <div className="space-y-4">
                      <div>
                        <label className="text-sm font-medium mb-2 block">Composition Mode</label>
                        <select
                          value={patternCombination.compositionMode}
                          onChange={(e) => setPatternCombination(prev => ({
                            ...prev,
                            compositionMode: e.target.value as any
                          }))}
                          className="w-full p-2 rounded border border-border bg-background"
                        >
                          <option value="overlay">Overlay</option>
                          <option value="multiply">Multiply</option>
                          <option value="screen">Screen</option>
                          <option value="difference">Difference</option>
                        </select>
                      </div>

                      <button
                        onClick={() => {
                          // Add logic to add pattern to combination
                        }}
                        className="w-full py-2 border-2 border-dashed border-border rounded-lg flex items-center justify-center gap-2 text-muted-foreground hover:border-primary hover:text-primary transition-colors"
                      >
                        <Plus className="h-4 w-4" />
                        Add Pattern Layer
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Preview Panel */}
            <div className="flex-1 p-6 flex flex-col">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-semibold">Preview</h3>
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => exportPattern('png')}
                    className="p-2 hover:bg-accent rounded-md transition-colors"
                    title="Export as PNG"
                  >
                    <Download className="h-4 w-4" />
                  </button>
                  <button
                    onClick={() => exportPattern('svg')}
                    className="p-2 hover:bg-accent rounded-md transition-colors"
                    title="Export as SVG"
                  >
                    <Download className="h-4 w-4" />
                  </button>
                  <button
                    onClick={() => exportPattern('json')}
                    className="p-2 hover:bg-accent rounded-md transition-colors"
                    title="Export as JSON"
                  >
                    <Download className="h-4 w-4" />
                  </button>
                </div>
              </div>

              <div className="flex-1 bg-gray-100 rounded-lg overflow-hidden flex items-center justify-center">
                <canvas
                  ref={canvasRef}
                  width={previewSize.width}
                  height={previewSize.height}
                  className="max-w-full max-h-full object-contain"
                />
              </div>

              <div className="mt-4 flex items-center gap-4">
                <label className="text-sm font-medium">Preview Size:</label>
                <input
                  type="range"
                  min="200"
                  max="800"
                  step="50"
                  value={previewSize.width}
                  onChange={(e) => {
                    const size = parseInt(e.target.value);
                    setPreviewSize({ width: size, height: size });
                  }}
                  className="flex-1"
                />
                <span className="text-sm">{previewSize.width}px</span>
              </div>
            </div>
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
}

// Helper function to get default parameters for a pattern
function getDefaultParameters(pattern: PatternType): PatternParameterConfig[] {
  const baseParams: PatternParameterConfig[] = [
    {
      name: 'scale',
      type: 'range',
      min: 0.1,
      max: 3,
      step: 0.1,
      value: 1,
      description: 'Scale of the pattern'
    },
    {
      name: 'rotation',
      type: 'range',
      min: 0,
      max: 360,
      step: 1,
      value: 0,
      description: 'Rotation angle in degrees'
    },
    {
      name: 'color1',
      type: 'color',
      value: '#1e40af',
      description: 'Primary color'
    },
    {
      name: 'color2',
      type: 'color',
      value: '#60a5fa',
      description: 'Secondary color'
    }
  ];

  // Add pattern-specific parameters
  switch (pattern) {
    case PatternType.Seigaiha:
      baseParams.push({
        name: 'waveHeight',
        type: 'range',
        min: 0.5,
        max: 2,
        step: 0.1,
        value: 1,
        description: 'Wave height multiplier'
      });
      break;
    case PatternType.Asanoha:
      baseParams.push({
        name: 'lineWidth',
        type: 'range',
        min: 1,
        max: 5,
        step: 0.5,
        value: 2,
        description: 'Line width'
      });
      break;
    case PatternType.Tatewaku:
      baseParams.push({
        name: 'complexity',
        type: 'range',
        min: 3,
        max: 10,
        step: 1,
        value: 5,
        description: 'Pattern complexity'
      });
      break;
  }

  return baseParams;
}
import React, { useState } from 'react'
import { 
  MousePointer, 
  Pencil, 
  Square, 
  Circle, 
  Triangle,
  Type,
  Trash2,
  Download,
  Palette,
  Sparkles
} from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'

interface CanvasControlsProps {
  onModeChange: (mode: 'select' | 'draw' | 'shape' | 'text') => void
  onAddShape: (type: 'rect' | 'circle' | 'triangle') => void
  onClear: () => void
  onExport: () => void
  onTogglePatterns: () => void
  showPatternLibrary: boolean
  onGenerateTestPattern: () => void
}

export function CanvasControls({
  onModeChange,
  onAddShape,
  onClear,
  onExport,
  onTogglePatterns,
  showPatternLibrary,
  onGenerateTestPattern
}: CanvasControlsProps) {
  const [activeMode, setActiveMode] = useState<'select' | 'draw' | 'shape' | 'text'>('select')
  const [showShapeMenu, setShowShapeMenu] = useState(false)

  const handleModeChange = (mode: 'select' | 'draw' | 'shape' | 'text') => {
    setActiveMode(mode)
    onModeChange(mode)
    
    if (mode === 'shape') {
      setShowShapeMenu(true)
    } else {
      setShowShapeMenu(false)
    }
  }

  const tools = [
    { id: 'select', icon: MousePointer, name: 'Select', shortcut: 'V' },
    { id: 'draw', icon: Pencil, name: 'Draw', shortcut: 'P' },
    { id: 'shape', icon: Square, name: 'Shapes', shortcut: 'R' },
    { id: 'text', icon: Type, name: 'Text', shortcut: 'T' }
  ]

  const shapes = [
    { id: 'rect', icon: Square, name: 'Rectangle' },
    { id: 'circle', icon: Circle, name: 'Circle' },
    { id: 'triangle', icon: Triangle, name: 'Triangle' }
  ]


  return (
    <>
      {/* Floating toolbar */}
      <div className="absolute top-4 left-4 bg-card rounded-lg shadow-lg border border-border p-1 flex items-center gap-1">
        {tools.map((tool) => {
          const Icon = tool.icon
          const isActive = activeMode === tool.id
          
          return (
            <button
              key={tool.id}
              onClick={() => handleModeChange(tool.id as any)}
              className={`p-2.5 rounded-md transition-colors relative group ${
                isActive 
                  ? 'bg-primary text-primary-foreground' 
                  : 'hover:bg-accent'
              }`}
              aria-label={tool.name}
            >
              <Icon className="h-5 w-5" />
              
              {/* Tooltip */}
              <div className="absolute -bottom-10 left-1/2 -translate-x-1/2 px-2 py-1 bg-popover text-popover-foreground text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
                {tool.name} ({tool.shortcut})
              </div>
            </button>
          )
        })}
        
        <div className="w-px h-8 bg-border mx-1" />
        
        {/* Clear canvas */}
        <button
          onClick={onClear}
          className="p-2.5 hover:bg-accent rounded-md transition-colors group"
          aria-label="Clear canvas"
        >
          <Trash2 className="h-5 w-5" />
          
          <div className="absolute -bottom-10 left-1/2 -translate-x-1/2 px-2 py-1 bg-popover text-popover-foreground text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
            Clear
          </div>
        </button>
        
        <div className="w-px h-8 bg-border mx-1" />
        
        {/* Export */}
        <button
          onClick={onExport}
          className="p-2.5 hover:bg-accent rounded-md transition-colors group"
          aria-label="Export"
        >
          <Download className="h-5 w-5" />
          
          <div className="absolute -bottom-10 left-1/2 -translate-x-1/2 px-2 py-1 bg-popover text-popover-foreground text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
            Export
          </div>
        </button>
        
        {/* Test Pattern */}
        <button
          onClick={onGenerateTestPattern}
          className="p-2.5 hover:bg-accent rounded-md transition-colors group"
          aria-label="Generate Test Pattern"
        >
          <Sparkles className="h-5 w-5" />
          
          <div className="absolute -bottom-10 left-1/2 -translate-x-1/2 px-2 py-1 bg-popover text-popover-foreground text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
            Test Pattern
          </div>
        </button>
        
        {/* Pattern Library Toggle */}
        <button
          onClick={onTogglePatterns}
          className={`p-2.5 rounded-md transition-colors group ${
            showPatternLibrary 
              ? 'bg-primary text-primary-foreground' 
              : 'hover:bg-accent'
          }`}
          aria-label="Toggle Pattern Library"
        >
          <Palette className="h-5 w-5" />
          
          <div className="absolute -bottom-10 left-1/2 -translate-x-1/2 px-2 py-1 bg-popover text-popover-foreground text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
            Patterns
          </div>
        </button>
      </div>

      {/* Shape selection menu */}
      <AnimatePresence>
        {showShapeMenu && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute top-20 left-4 bg-card rounded-lg shadow-lg border border-border p-2"
          >
            <div className="text-xs font-medium text-muted-foreground mb-2 px-2">
              Select Shape
            </div>
            {shapes.map((shape) => {
              const Icon = shape.icon
              return (
                <button
                  key={shape.id}
                  onClick={() => {
                    onAddShape(shape.id as any)
                    setShowShapeMenu(false)
                  }}
                  className="w-full flex items-center gap-3 px-3 py-2 hover:bg-accent rounded-md transition-colors"
                >
                  <Icon className="h-4 w-4" />
                  <span className="text-sm">{shape.name}</span>
                </button>
              )
            })}
          </motion.div>
        )}
      </AnimatePresence>


      {/* Keyboard shortcuts hint */}
      <div className="absolute bottom-4 left-4 text-xs text-muted-foreground bg-card/80 backdrop-blur px-3 py-2 rounded-md">
        <span className="opacity-60">Press</span>{' '}
        <kbd className="px-1.5 py-0.5 bg-muted rounded text-[10px]">Space</kbd>{' '}
        <span className="opacity-60">to pan •</span>{' '}
        <kbd className="px-1.5 py-0.5 bg-muted rounded text-[10px]">⌘/Ctrl</kbd>{' '}
        <span className="opacity-60">+ scroll to zoom</span>
      </div>
    </>
  )
}
import React, { useState, useEffect } from 'react'
import { 
  Download, 
  FileImage, 
  FileText, 
  Code, 
  Eye,
  X,
  Check,
  FileType,
  Printer
} from 'lucide-react'
import { motion } from 'framer-motion'
import { 
  SVGExporter, 
  PDFExporter, 
  EPSExporter,
  SVGExportOptions,
  PDFExportOptions,
  EPSExportOptions,
  downloadFile
} from '../../utils/vectorExport'

interface ExportDialogProps {
  isOpen: boolean
  onClose: () => void
  canvas: any | null
}

interface ExportOptions {
  format: 'png' | 'svg' | 'css' | 'pdf' | 'eps'
  quality: number
  resolution: 'web' | 'print' | 'custom'
  customWidth: number
  customHeight: number
  backgroundColor: string
  includeBackground: boolean
  cssType: 'background' | 'pattern' | 'mask'
  cssUnits: 'px' | '%' | 'em' | 'rem'
  cssRepeat: 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat'
  // SVG specific options
  svgOptimize: boolean
  svgPrecision: number
  svgIncludeLayers: boolean
  // PDF specific options
  pdfFormat: 'a4' | 'a3' | 'letter' | 'custom'
  pdfOrientation: 'portrait' | 'landscape'
  pdfColorSpace: 'RGB' | 'CMYK'
  // EPS specific options
  epsLevel: 2 | 3
  epsColorSpace: 'RGB' | 'CMYK' | 'Grayscale'
  // Metadata options
  includeMetadata: boolean
  title: string
  author: string
  description: string
  keywords: string[]
}

const presetResolutions = {
  web: { width: 1920, height: 1080, label: 'Web HD (1920x1080)' },
  print: { width: 3508, height: 2480, label: 'Print A4 (300 DPI)' },
  mobile: { width: 375, height: 667, label: 'Mobile (375x667)' },
  tablet: { width: 768, height: 1024, label: 'Tablet (768x1024)' }
}

export function ExportDialog({ isOpen, onClose, canvas }: ExportDialogProps) {
  const [options, setOptions] = useState<ExportOptions>({
    format: 'png',
    quality: 1,
    resolution: 'web',
    customWidth: 1920,
    customHeight: 1080,
    backgroundColor: '#ffffff',
    includeBackground: true,
    cssType: 'background',
    cssUnits: 'px',
    cssRepeat: 'repeat',
    // SVG options
    svgOptimize: true,
    svgPrecision: 2,
    svgIncludeLayers: true,
    // PDF options
    pdfFormat: 'a4',
    pdfOrientation: 'portrait',
    pdfColorSpace: 'RGB',
    // EPS options
    epsLevel: 3,
    epsColorSpace: 'RGB',
    // Metadata
    includeMetadata: true,
    title: 'Genshi Pattern',
    author: 'Genshi Studio',
    description: '',
    keywords: ['pattern', 'generative', 'art']
  })
  
  const [preview, setPreview] = useState<string | null>(null)
  const [isGenerating, setIsGenerating] = useState(false)
  const [exportCode, setExportCode] = useState<string>('')

  // Generate preview when options change
  useEffect(() => {
    if (isOpen && canvas) {
      generatePreview()
    }
  }, [isOpen, canvas, options])

  const generatePreview = async () => {
    if (!canvas) return
    
    setIsGenerating(true)
    
    try {
      switch (options.format) {
        case 'png':
          generatePNGPreview()
          break
        case 'svg':
          generateSVGPreview()
          break
        case 'pdf':
          generatePDFPreview()
          break
        case 'eps':
          generateEPSPreview()
          break
        case 'css':
          generateCSSPreview()
          break
      }
    } catch (error) {
      console.error('Preview generation error:', error)
    } finally {
      setIsGenerating(false)
    }
  }

  const generatePNGPreview = () => {
    if (!canvas) return
    
    const { width, height } = getExportDimensions()
    const multiplier = Math.min(300 / width, 200 / height, 1)
    
    const dataURL = canvas.toDataURL({
      format: 'png',
      quality: options.quality,
      multiplier,
      backgroundColor: options.includeBackground ? options.backgroundColor : 'transparent'
    })
    
    setPreview(dataURL)
  }

  const generateSVGPreview = async () => {
    if (!canvas) return
    
    const svgOptions: SVGExportOptions = {
      optimize: options.svgOptimize,
      embedStyles: true,
      includeLayers: options.svgIncludeLayers,
      preservePatterns: true,
      precision: options.svgPrecision,
      includeMetadata: options.includeMetadata,
      title: options.title,
      description: options.description,
      creator: options.author
    }
    
    const svgString = await SVGExporter.exportFromCanvas(canvas, svgOptions)
    const svgBlob = new Blob([svgString], { type: 'image/svg+xml' })
    const svgURL = URL.createObjectURL(svgBlob)
    setPreview(svgURL)
  }

  const generatePDFPreview = () => {
    if (!canvas) return
    
    // For PDF preview, show the canvas as PNG
    generatePNGPreview()
    setExportCode('PDF Export Ready\nFormat: ' + options.pdfFormat.toUpperCase() + '\nOrientation: ' + options.pdfOrientation)
  }

  const generateEPSPreview = () => {
    if (!canvas) return
    
    // For EPS preview, show the canvas as PNG
    generatePNGPreview()
    setExportCode('EPS Export Ready\nLevel: PostScript Level ' + options.epsLevel + '\nColor Space: ' + options.epsColorSpace)
  }

  const generateCSSPreview = () => {
    if (!canvas) return
    
    const cssCode = generateCSSPattern()
    setExportCode(cssCode)
    
    // Create a preview using a temporary canvas
    const tempCanvas = document.createElement('canvas')
    tempCanvas.width = 300
    tempCanvas.height = 200
    const ctx = tempCanvas.getContext('2d')
    
    if (ctx) {
      // Apply the CSS pattern as a canvas pattern
      const patternCanvas = document.createElement('canvas')
      patternCanvas.width = canvas.width!
      patternCanvas.height = canvas.height!
      const patternCtx = patternCanvas.getContext('2d')
      
      if (patternCtx) {
        // Draw the fabric canvas content to pattern canvas
        const fabricCanvas = canvas.getElement()
        patternCtx.drawImage(fabricCanvas, 0, 0)
        
        // Create pattern and fill the preview
        const pattern = ctx.createPattern(patternCanvas, options.cssRepeat)
        if (pattern) {
          ctx.fillStyle = pattern
          ctx.fillRect(0, 0, 300, 200)
        }
      }
    }
    
    setPreview(tempCanvas.toDataURL())
  }

  const getExportDimensions = () => {
    if (options.resolution === 'custom') {
      return { width: options.customWidth, height: options.customHeight }
    }
    
    const preset = presetResolutions[options.resolution as keyof typeof presetResolutions]
    return preset || presetResolutions.web
  }

  const generateCSSPattern = (): string => {
    if (!canvas) return ''
    
    const { width, height } = getExportDimensions()
    const dataURL = canvas.toDataURL({
      format: 'png',
      quality: options.quality,
      backgroundColor: options.includeBackground ? options.backgroundColor : 'transparent'
    })
    
    const sizeValue = options.cssUnits === '%' ? '100%' : `${width}${options.cssUnits}`
    
    switch (options.cssType) {
      case 'background':
        return `.pattern-background {
  background-image: url('${dataURL}');
  background-size: ${sizeValue};
  background-repeat: ${options.cssRepeat};
  background-position: center;
}`
      
      case 'pattern':
        return `.pattern-element {
  width: ${width}${options.cssUnits};
  height: ${height}${options.cssUnits};
  background: url('${dataURL}');
  background-size: cover;
  background-repeat: ${options.cssRepeat};
}`
      
      case 'mask':
        return `.pattern-mask {
  mask-image: url('${dataURL}');
  mask-size: ${sizeValue};
  mask-repeat: ${options.cssRepeat};
  mask-position: center;
  -webkit-mask-image: url('${dataURL}');
  -webkit-mask-size: ${sizeValue};
  -webkit-mask-repeat: ${options.cssRepeat};
  -webkit-mask-position: center;
}`
      
      default:
        return ''
    }
  }

  const handleExport = async () => {
    if (!canvas) return
    
    setIsGenerating(true)
    
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
      
      switch (options.format) {
        case 'png':
          const pngDataURL = canvas.toDataURL({
            format: 'png',
            quality: options.quality,
            multiplier: options.resolution === 'print' ? 2 : 1,
            backgroundColor: options.includeBackground ? options.backgroundColor : 'transparent'
          })
          downloadFile(pngDataURL, `genshi-pattern-${timestamp}.png`)
          break
          
        case 'svg':
          const svgOptions: SVGExportOptions = {
            optimize: options.svgOptimize,
            embedStyles: true,
            includeLayers: options.svgIncludeLayers,
            preservePatterns: true,
            precision: options.svgPrecision,
            includeMetadata: options.includeMetadata,
            title: options.title,
            description: options.description,
            creator: options.author,
            license: 'Creative Commons BY 4.0'
          }
          const svgContent = await SVGExporter.exportFromCanvas(canvas, svgOptions)
          downloadFile(svgContent, `genshi-pattern-${timestamp}.svg`, 'image/svg+xml')
          break
          
        case 'pdf':
          const pdfOptions: PDFExportOptions = {
            format: options.pdfFormat,
            orientation: options.pdfOrientation,
            colorSpace: options.pdfColorSpace,
            compression: true,
            embedFonts: true,
            dpi: 300,
            customWidth: options.customWidth,
            customHeight: options.customHeight,
            includeMetadata: options.includeMetadata,
            title: options.title,
            subject: options.description,
            author: options.author,
            keywords: options.keywords
          }
          const pdfBlob = await PDFExporter.exportFromCanvas(canvas, pdfOptions)
          downloadFile(pdfBlob, `genshi-pattern-${timestamp}.pdf`, 'application/pdf')
          break
          
        case 'eps':
          const epsOptions: EPSExportOptions = {
            level: options.epsLevel,
            colorSpace: options.epsColorSpace,
            includePreview: false,
            resolution: 300,
            boundingBox: 'tight',
            includeMetadata: options.includeMetadata,
            title: options.title,
            creator: options.author,
            creationDate: new Date()
          }
          const epsContent = await EPSExporter.exportFromCanvas(canvas, epsOptions)
          downloadFile(epsContent, `genshi-pattern-${timestamp}.eps`, 'application/postscript')
          break
          
        case 'css':
          const cssCode = generateCSSPattern()
          const cssBlob = new Blob([cssCode], { type: 'text/css' })
          const cssURL = URL.createObjectURL(cssBlob)
          downloadFile(cssURL, `genshi-pattern-${timestamp}.css`)
          break
      }
      
      onClose()
    } catch (error) {
      console.error('Export error:', error)
    } finally {
      setIsGenerating(false)
    }
  }

  // Download file function is now imported from vectorExport.ts

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text).then(() => {
      // You could add a toast notification here
    })
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="bg-card rounded-lg shadow-xl border border-border w-full max-w-4xl max-h-[90vh] overflow-hidden"
      >
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-border">
          <h2 className="text-xl font-semibold">Export Pattern</h2>
          <button
            onClick={onClose}
            className="p-2 hover:bg-accent rounded-md transition-colors"
          >
            <X className="h-5 w-5" />
          </button>
        </div>

        <div className="flex h-[600px]">
          {/* Options Panel */}
          <div className="w-80 border-r border-border p-6 overflow-y-auto">
            <div className="space-y-6">
              {/* Format Selection */}
              <div>
                <label className="block text-sm font-medium mb-3">Export Format</label>
                <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-5 gap-2">
                  {[
                    { id: 'png', icon: FileImage, label: 'PNG' },
                    { id: 'svg', icon: FileText, label: 'SVG' },
                    { id: 'pdf', icon: FileType, label: 'PDF' },
                    { id: 'eps', icon: Printer, label: 'EPS' },
                    { id: 'css', icon: Code, label: 'CSS' }
                  ].map((format) => {
                    const Icon = format.icon
                    return (
                      <button
                        key={format.id}
                        onClick={() => setOptions({ ...options, format: format.id as any })}
                        className={`p-3 rounded-lg border transition-colors ${
                          options.format === format.id
                            ? 'border-primary bg-primary/10 text-primary'
                            : 'border-border hover:bg-accent'
                        }`}
                      >
                        <Icon className="h-5 w-5 mx-auto mb-1" />
                        <div className="text-xs">{format.label}</div>
                      </button>
                    )
                  })}
                </div>
              </div>

              {/* PNG Options */}
              {options.format === 'png' && (
                <>
                  {/* Quality */}
                  {options.format === 'png' && (
                    <div>
                      <label className="block text-sm font-medium mb-2">
                        Quality: {Math.round(options.quality * 100)}%
                      </label>
                      <input
                        type="range"
                        min="0.1"
                        max="1"
                        step="0.1"
                        value={options.quality}
                        onChange={(e) => setOptions({ ...options, quality: parseFloat(e.target.value) })}
                        className="w-full"
                      />
                    </div>
                  )}

                  {/* Resolution */}
                  <div>
                    <label className="block text-sm font-medium mb-2">Resolution</label>
                    <select
                      value={options.resolution}
                      onChange={(e) => setOptions({ ...options, resolution: e.target.value as any })}
                      className="w-full p-2 border border-border rounded-md bg-background"
                    >
                      <option value="web">Web (1920x1080)</option>
                      <option value="print">Print (300 DPI)</option>
                      <option value="custom">Custom</option>
                    </select>
                  </div>

                  {/* Custom Dimensions */}
                  {options.resolution === 'custom' && (
                    <div className="grid grid-cols-2 gap-2">
                      <div>
                        <label className="block text-xs font-medium mb-1">Width</label>
                        <input
                          type="number"
                          value={options.customWidth}
                          onChange={(e) => setOptions({ ...options, customWidth: parseInt(e.target.value) })}
                          className="w-full p-2 border border-border rounded-md bg-background"
                        />
                      </div>
                      <div>
                        <label className="block text-xs font-medium mb-1">Height</label>
                        <input
                          type="number"
                          value={options.customHeight}
                          onChange={(e) => setOptions({ ...options, customHeight: parseInt(e.target.value) })}
                          className="w-full p-2 border border-border rounded-md bg-background"
                        />
                      </div>
                    </div>
                  )}

                </>
              )}

              {/* SVG Options */}
              {options.format === 'svg' && (
                <>
                  <div>
                    <div className="flex items-center gap-2 mb-2">
                      <input
                        type="checkbox"
                        id="svgOptimize"
                        checked={options.svgOptimize}
                        onChange={(e) => setOptions({ ...options, svgOptimize: e.target.checked })}
                        className="rounded"
                      />
                      <label htmlFor="svgOptimize" className="text-sm font-medium">
                        Optimize paths
                      </label>
                    </div>
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium mb-2">
                      Precision: {options.svgPrecision} decimals
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="6"
                      step="1"
                      value={options.svgPrecision}
                      onChange={(e) => setOptions({ ...options, svgPrecision: parseInt(e.target.value) })}
                      className="w-full"
                    />
                  </div>
                  
                  <div>
                    <div className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        id="svgIncludeLayers"
                        checked={options.svgIncludeLayers}
                        onChange={(e) => setOptions({ ...options, svgIncludeLayers: e.target.checked })}
                        className="rounded"
                      />
                      <label htmlFor="svgIncludeLayers" className="text-sm font-medium">
                        Include layer structure
                      </label>
                    </div>
                  </div>
                </>
              )}

              {/* PDF Options */}
              {options.format === 'pdf' && (
                <>
                  <div>
                    <label className="block text-sm font-medium mb-2">Page Format</label>
                    <select
                      value={options.pdfFormat}
                      onChange={(e) => setOptions({ ...options, pdfFormat: e.target.value as any })}
                      className="w-full p-2 border border-border rounded-md bg-background"
                    >
                      <option value="a4">A4</option>
                      <option value="a3">A3</option>
                      <option value="letter">Letter</option>
                      <option value="custom">Custom</option>
                    </select>
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium mb-2">Orientation</label>
                    <div className="grid grid-cols-2 gap-2">
                      <button
                        onClick={() => setOptions({ ...options, pdfOrientation: 'portrait' })}
                        className={`p-2 rounded-md border transition-colors ${
                          options.pdfOrientation === 'portrait'
                            ? 'border-primary bg-primary/10 text-primary'
                            : 'border-border hover:bg-accent'
                        }`}
                      >
                        Portrait
                      </button>
                      <button
                        onClick={() => setOptions({ ...options, pdfOrientation: 'landscape' })}
                        className={`p-2 rounded-md border transition-colors ${
                          options.pdfOrientation === 'landscape'
                            ? 'border-primary bg-primary/10 text-primary'
                            : 'border-border hover:bg-accent'
                        }`}
                      >
                        Landscape
                      </button>
                    </div>
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium mb-2">Color Space</label>
                    <select
                      value={options.pdfColorSpace}
                      onChange={(e) => setOptions({ ...options, pdfColorSpace: e.target.value as any })}
                      className="w-full p-2 border border-border rounded-md bg-background"
                    >
                      <option value="RGB">RGB (Screen)</option>
                      <option value="CMYK">CMYK (Print)</option>
                    </select>
                  </div>
                </>
              )}

              {/* EPS Options */}
              {options.format === 'eps' && (
                <>
                  <div>
                    <label className="block text-sm font-medium mb-2">PostScript Level</label>
                    <select
                      value={options.epsLevel}
                      onChange={(e) => setOptions({ ...options, epsLevel: parseInt(e.target.value) as any })}
                      className="w-full p-2 border border-border rounded-md bg-background"
                    >
                      <option value="2">Level 2</option>
                      <option value="3">Level 3</option>
                    </select>
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium mb-2">Color Space</label>
                    <select
                      value={options.epsColorSpace}
                      onChange={(e) => setOptions({ ...options, epsColorSpace: e.target.value as any })}
                      className="w-full p-2 border border-border rounded-md bg-background"
                    >
                      <option value="RGB">RGB</option>
                      <option value="CMYK">CMYK</option>
                      <option value="Grayscale">Grayscale</option>
                    </select>
                  </div>
                </>
              )}

              {/* Background option for all formats except CSS */}
              {options.format !== 'css' && (
                <div>
                  <div className="flex items-center gap-2 mb-2">
                    <input
                      type="checkbox"
                      id="includeBackground"
                      checked={options.includeBackground}
                      onChange={(e) => setOptions({ ...options, includeBackground: e.target.checked })}
                      className="rounded"
                    />
                    <label htmlFor="includeBackground" className="text-sm font-medium">
                      Include background
                    </label>
                  </div>
                  {options.includeBackground && (
                    <input
                      type="color"
                      value={options.backgroundColor}
                      onChange={(e) => setOptions({ ...options, backgroundColor: e.target.value })}
                      className="w-full h-10 rounded-md border border-border"
                    />
                  )}
                </div>
              )}

              {/* Metadata Options for SVG, PDF, EPS */}
              {(options.format === 'svg' || options.format === 'pdf' || options.format === 'eps') && (
                <>
                  <div className="border-t border-border pt-4">
                    <div className="flex items-center gap-2 mb-3">
                      <input
                        type="checkbox"
                        id="includeMetadata"
                        checked={options.includeMetadata}
                        onChange={(e) => setOptions({ ...options, includeMetadata: e.target.checked })}
                        className="rounded"
                      />
                      <label htmlFor="includeMetadata" className="text-sm font-medium">
                        Include metadata
                      </label>
                    </div>
                    
                    {options.includeMetadata && (
                      <div className="space-y-3 ml-6">
                        <div>
                          <label className="block text-xs font-medium mb-1">Title</label>
                          <input
                            type="text"
                            value={options.title}
                            onChange={(e) => setOptions({ ...options, title: e.target.value })}
                            className="w-full p-1.5 text-sm border border-border rounded-md bg-background"
                            placeholder="Pattern title"
                          />
                        </div>
                        
                        <div>
                          <label className="block text-xs font-medium mb-1">Author</label>
                          <input
                            type="text"
                            value={options.author}
                            onChange={(e) => setOptions({ ...options, author: e.target.value })}
                            className="w-full p-1.5 text-sm border border-border rounded-md bg-background"
                            placeholder="Your name or organization"
                          />
                        </div>
                        
                        <div>
                          <label className="block text-xs font-medium mb-1">Description</label>
                          <textarea
                            value={options.description}
                            onChange={(e) => setOptions({ ...options, description: e.target.value })}
                            className="w-full p-1.5 text-sm border border-border rounded-md bg-background h-16 resize-none"
                            placeholder="Pattern description"
                          />
                        </div>
                        
                        {options.format === 'pdf' && (
                          <div>
                            <label className="block text-xs font-medium mb-1">Keywords</label>
                            <input
                              type="text"
                              value={options.keywords.join(', ')}
                              onChange={(e) => setOptions({ ...options, keywords: e.target.value.split(',').map(k => k.trim()).filter(k => k) })}
                              className="w-full p-1.5 text-sm border border-border rounded-md bg-background"
                              placeholder="pattern, generative, art"
                            />
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                </>
              )}

              {/* CSS Options */}
              {options.format === 'css' && (
                <>
                  <div>
                    <label className="block text-sm font-medium mb-2">CSS Type</label>
                    <select
                      value={options.cssType}
                      onChange={(e) => setOptions({ ...options, cssType: e.target.value as any })}
                      className="w-full p-2 border border-border rounded-md bg-background"
                    >
                      <option value="background">Background Pattern</option>
                      <option value="pattern">Pattern Element</option>
                      <option value="mask">CSS Mask</option>
                    </select>
                  </div>

                  <div>
                    <label className="block text-sm font-medium mb-2">Units</label>
                    <select
                      value={options.cssUnits}
                      onChange={(e) => setOptions({ ...options, cssUnits: e.target.value as any })}
                      className="w-full p-2 border border-border rounded-md bg-background"
                    >
                      <option value="px">Pixels (px)</option>
                      <option value="%">Percentage (%)</option>
                      <option value="em">Em units (em)</option>
                      <option value="rem">Rem units (rem)</option>
                    </select>
                  </div>

                  <div>
                    <label className="block text-sm font-medium mb-2">Repeat</label>
                    <select
                      value={options.cssRepeat}
                      onChange={(e) => setOptions({ ...options, cssRepeat: e.target.value as any })}
                      className="w-full p-2 border border-border rounded-md bg-background"
                    >
                      <option value="repeat">Repeat</option>
                      <option value="repeat-x">Repeat X</option>
                      <option value="repeat-y">Repeat Y</option>
                      <option value="no-repeat">No Repeat</option>
                    </select>
                  </div>
                </>
              )}
            </div>
          </div>

          {/* Preview Panel */}
          <div className="flex-1 p-6">
            <div className="h-full flex flex-col">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium">Preview</h3>
                <div className="flex gap-2">
                  <button
                    onClick={generatePreview}
                    disabled={isGenerating}
                    className="flex items-center gap-2 px-3 py-1.5 bg-accent rounded-md hover:bg-accent/80 transition-colors disabled:opacity-50"
                  >
                    <Eye className="h-4 w-4" />
                    Refresh
                  </button>
                </div>
              </div>

              <div className="flex-1 bg-accent/20 rounded-lg p-4 overflow-auto">
                {isGenerating ? (
                  <div className="flex items-center justify-center h-full">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
                  </div>
                ) : (
                  <div className="h-full flex items-center justify-center">
                    {(options.format === 'pdf' || options.format === 'eps') ? (
                      <div className="text-center space-y-4">
                        {preview && (
                          <img 
                            src={preview} 
                            alt="Preview" 
                            className="max-w-full max-h-48 object-contain border border-border rounded mx-auto"
                          />
                        )}
                        <div className="bg-card rounded-lg p-4 border border-border">
                          <pre className="text-xs text-muted-foreground">
                            <code>{exportCode}</code>
                          </pre>
                        </div>
                      </div>
                    ) : options.format === 'css' ? (
                      <div className="w-full h-full space-y-4">
                        <div className="bg-card rounded-lg p-4 border border-border">
                          <div className="flex items-center justify-between mb-2">
                            <span className="text-sm font-medium">Generated CSS</span>
                            <button
                              onClick={() => copyToClipboard(exportCode)}
                              className="p-1 hover:bg-accent rounded transition-colors"
                            >
                              <Check className="h-4 w-4" />
                            </button>
                          </div>
                          <pre className="text-xs bg-accent/50 p-3 rounded overflow-x-auto">
                            <code>{exportCode}</code>
                          </pre>
                        </div>
                        {preview && (
                          <div className="bg-card rounded-lg p-4 border border-border">
                            <div className="text-sm font-medium mb-2">Pattern Preview</div>
                            <img 
                              src={preview} 
                              alt="Pattern preview" 
                              className="max-w-full h-48 object-contain border border-border rounded"
                            />
                          </div>
                        )}
                      </div>
                    ) : (
                      preview && (
                        <img 
                          src={preview} 
                          alt="Export preview" 
                          className="max-w-full max-h-full object-contain border border-border rounded"
                        />
                      )
                    )}
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="flex items-center justify-between p-6 border-t border-border">
          <div className="text-sm text-muted-foreground">
            {options.format === 'png' && `${getExportDimensions().width}x${getExportDimensions().height} pixels`}
            {options.format === 'svg' && 'Scalable vector format (optimized)'}
            {options.format === 'pdf' && `PDF ${options.pdfFormat.toUpperCase()} ${options.pdfOrientation}`}
            {options.format === 'eps' && `EPS Level ${options.epsLevel} - ${options.epsColorSpace}`}
            {options.format === 'css' && 'CSS pattern code'}
          </div>
          <div className="flex gap-2">
            <button
              onClick={onClose}
              className="px-4 py-2 border border-border rounded-md hover:bg-accent transition-colors"
            >
              Cancel
            </button>
            <button
              onClick={handleExport}
              disabled={isGenerating}
              className="flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors disabled:opacity-50"
            >
              <Download className="h-4 w-4" />
              Export
            </button>
          </div>
        </div>
      </motion.div>
    </div>
  )
}
import React, { useState, useEffect, useRef, useCallback } from 'react'
import { Play, Pause, RotateCcw, Download, Settings, Zap, Palette, Maximize2, MousePointer } from 'lucide-react'
import { OrganicPatternGenerator, OrganicPatternType } from '../../graphics/patterns/OrganicPatternGenerator'

interface GrowthSettings {
  type: OrganicPatternType
  growthRate: number
  density: number
  particleCount: number
  primaryColor: string
  secondaryColor: string
  accentColor: string
  speed: number
  interactive: boolean
  autoGrowth: boolean
}

export function InteractiveGrowthStudio() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const animationRef = useRef<number>()
  const patternGeneratorRef = useRef<OrganicPatternGenerator>()
  const lastFrameTime = useRef<number>(0)
  const mousePos = useRef({ x: 0, y: 0 })
  
  const [isPlaying, setIsPlaying] = useState(true)
  const [showSettings, setShowSettings] = useState(false)
  const [settings, setSettings] = useState<GrowthSettings>({
    type: OrganicPatternType.GrowthPattern,
    growthRate: 0.02,
    density: 0.3,
    particleCount: 1000,
    primaryColor: '#000000',
    secondaryColor: '#00ff88',
    accentColor: '#ff0088',
    speed: 1,
    interactive: true,
    autoGrowth: true
  })
  
  // Growth state
  const growthStateRef = useRef<{
    points: Set<string>
    generation: number
    centerX: number
    centerY: number
  }>({
    points: new Set(),
    generation: 0,
    centerX: 0,
    centerY: 0
  })

  // Initialize pattern generator
  useEffect(() => {
    patternGeneratorRef.current = new OrganicPatternGenerator()
    return () => {
      patternGeneratorRef.current?.destroy()
    }
  }, [])

  // Initialize canvas and growth
  useEffect(() => {
    if (!canvasRef.current) return
    
    const canvas = canvasRef.current
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    
    // Initialize growth center
    growthStateRef.current.centerX = canvas.width / 2
    growthStateRef.current.centerY = canvas.height / 2
    growthStateRef.current.points.clear()
    growthStateRef.current.points.add(`${Math.floor(canvas.width / 2)},${Math.floor(canvas.height / 2)}`)
    growthStateRef.current.generation = 0
    
    const handleResize = () => {
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight
      reset()
    }
    
    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  // Mouse interaction
  useEffect(() => {
    if (!canvasRef.current || !settings.interactive) return
    
    const canvas = canvasRef.current
    
    const handleMouseMove = (e: MouseEvent) => {
      const rect = canvas.getBoundingClientRect()
      mousePos.current = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      }
    }
    
    const handleClick = (e: MouseEvent) => {
      const rect = canvas.getBoundingClientRect()
      const x = Math.floor(e.clientX - rect.left)
      const y = Math.floor(e.clientY - rect.top)
      
      // Add new growth seed at click position
      growthStateRef.current.points.add(`${x},${y}`)
    }
    
    canvas.addEventListener('mousemove', handleMouseMove)
    canvas.addEventListener('click', handleClick)
    
    return () => {
      canvas.removeEventListener('mousemove', handleMouseMove)
      canvas.removeEventListener('click', handleClick)
    }
  }, [settings.interactive])

  // Animation loop
  const animate = useCallback((timestamp: number) => {
    if (!canvasRef.current) return
    
    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')
    if (!ctx) return
    
    // Calculate delta time
    const deltaTime = timestamp - lastFrameTime.current
    lastFrameTime.current = timestamp
    
    // Clear canvas with trail effect
    ctx.fillStyle = `rgba(${parseInt(settings.primaryColor.slice(1, 3), 16)}, ${parseInt(settings.primaryColor.slice(3, 5), 16)}, ${parseInt(settings.primaryColor.slice(5, 7), 16)}, 0.02)`
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    
    // Growth simulation
    if (settings.autoGrowth && growthStateRef.current.generation % Math.max(1, Math.floor(10 / settings.speed)) === 0) {
      const newPoints = new Set<string>()
      
      growthStateRef.current.points.forEach(pos => {
        const [x, y] = pos.split(',').map(Number)
        
        // Try to grow in all directions
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (dx === 0 && dy === 0) continue
            
            const nx = x + dx
            const ny = y + dy
            
            if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height) {
              if (!growthStateRef.current.points.has(`${nx},${ny}`) && Math.random() < settings.growthRate) {
                newPoints.add(`${nx},${ny}`)
              }
            }
          }
        }
      })
      
      // Add new points
      newPoints.forEach(point => growthStateRef.current.points.add(point))
    }
    
    // Interactive growth from mouse position
    if (settings.interactive) {
      const mouseX = Math.floor(mousePos.current.x)
      const mouseY = Math.floor(mousePos.current.y)
      
      // Add growth around mouse with higher probability
      for (let dx = -5; dx <= 5; dx++) {
        for (let dy = -5; dy <= 5; dy++) {
          const nx = mouseX + dx
          const ny = mouseY + dy
          const distance = Math.sqrt(dx * dx + dy * dy)
          
          if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height) {
            if (!growthStateRef.current.points.has(`${nx},${ny}`) && 
                Math.random() < settings.growthRate * 2 / (distance + 1)) {
              growthStateRef.current.points.add(`${nx},${ny}`)
            }
          }
        }
      }
    }
    
    // Render growth pattern
    switch (settings.type) {
      case OrganicPatternType.GrowthPattern:
        renderGrowthPattern(ctx, canvas)
        break
      case OrganicPatternType.DiffusionLimited:
        renderDiffusionPattern(ctx, canvas)
        break
      case OrganicPatternType.CrystalGrowth:
        renderCrystalPattern(ctx, canvas)
        break
      case OrganicPatternType.FlowField:
        renderFlowField(ctx, canvas)
        break
      default:
        renderGrowthPattern(ctx, canvas)
    }
    
    growthStateRef.current.generation++
    
    if (isPlaying) {
      animationRef.current = requestAnimationFrame(animate)
    }
  }, [settings, isPlaying])

  const renderGrowthPattern = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {
    // Create gradient effect based on distance from center
    growthStateRef.current.points.forEach(pos => {
      const [x, y] = pos.split(',').map(Number)
      
      const dx = x - growthStateRef.current.centerX
      const dy = y - growthStateRef.current.centerY
      const distance = Math.sqrt(dx * dx + dy * dy)
      const maxDistance = Math.min(canvas.width, canvas.height) / 2
      
      const t = Math.min(1, distance / maxDistance)
      
      // Interpolate colors
      const r1 = parseInt(settings.secondaryColor.slice(1, 3), 16)
      const g1 = parseInt(settings.secondaryColor.slice(3, 5), 16)
      const b1 = parseInt(settings.secondaryColor.slice(5, 7), 16)
      
      const r2 = parseInt(settings.accentColor.slice(1, 3), 16)
      const g2 = parseInt(settings.accentColor.slice(3, 5), 16)
      const b2 = parseInt(settings.accentColor.slice(5, 7), 16)
      
      const r = Math.floor(r1 * (1 - t) + r2 * t)
      const g = Math.floor(g1 * (1 - t) + g2 * t)
      const b = Math.floor(b1 * (1 - t) + b2 * t)
      
      ctx.fillStyle = `rgb(${r}, ${g}, ${b})`
      ctx.fillRect(x, y, 1, 1)
    })
  }

  const renderDiffusionPattern = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {
    ctx.strokeStyle = settings.secondaryColor
    ctx.lineWidth = 0.5
    
    // Draw connections between nearby points
    const pointArray = Array.from(growthStateRef.current.points)
    
    pointArray.forEach((pos1, i) => {
      const [x1, y1] = pos1.split(',').map(Number)
      
      for (let j = i + 1; j < Math.min(i + 20, pointArray.length); j++) {
        const pos2 = pointArray[j]
        const [x2, y2] = pos2.split(',').map(Number)
        
        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        
        if (distance < 50) {
          ctx.globalAlpha = 1 - distance / 50
          ctx.beginPath()
          ctx.moveTo(x1, y1)
          ctx.lineTo(x2, y2)
          ctx.stroke()
        }
      }
    })
    
    ctx.globalAlpha = 1
  }

  const renderCrystalPattern = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {
    // Render as hexagonal crystals
    ctx.strokeStyle = settings.secondaryColor
    ctx.fillStyle = settings.accentColor + '20'
    ctx.lineWidth = 1
    
    growthStateRef.current.points.forEach(pos => {
      const [x, y] = pos.split(',').map(Number)
      
      // Check if this point should be rendered as a crystal center
      if ((x + y) % 10 === 0) {
        const size = 3
        
        ctx.beginPath()
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i
          const px = x + Math.cos(angle) * size
          const py = y + Math.sin(angle) * size
          
          if (i === 0) {
            ctx.moveTo(px, py)
          } else {
            ctx.lineTo(px, py)
          }
        }
        ctx.closePath()
        ctx.fill()
        ctx.stroke()
      } else {
        // Regular points
        ctx.fillStyle = settings.secondaryColor
        ctx.fillRect(x, y, 1, 1)
      }
    })
  }

  const renderFlowField = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {
    ctx.strokeStyle = settings.secondaryColor + '40'
    ctx.lineWidth = 1
    
    // Create flow lines from growth points
    growthStateRef.current.points.forEach(pos => {
      const [x, y] = pos.split(',').map(Number)
      
      if (Math.random() < 0.1) { // Only trace some points
        ctx.beginPath()
        ctx.moveTo(x, y)
        
        let currentX = x
        let currentY = y
        
        // Trace flow line
        for (let step = 0; step < 50; step++) {
          const noise = (Math.sin(currentX * 0.01) + Math.cos(currentY * 0.01)) * Math.PI
          const dx = Math.cos(noise) * 2
          const dy = Math.sin(noise) * 2
          
          currentX += dx
          currentY += dy
          
          if (currentX < 0 || currentX >= canvas.width || currentY < 0 || currentY >= canvas.height) break
          
          ctx.lineTo(currentX, currentY)
        }
        
        ctx.stroke()
      }
    })
  }

  // Start/stop animation
  useEffect(() => {
    if (isPlaying) {
      lastFrameTime.current = performance.now()
      animationRef.current = requestAnimationFrame(animate)
    } else {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current)
      }
    }
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current)
      }
    }
  }, [isPlaying, animate])

  const reset = () => {
    if (!canvasRef.current) return
    
    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')
    if (!ctx) return
    
    // Clear canvas
    ctx.fillStyle = settings.primaryColor
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    
    // Reset growth
    growthStateRef.current.points.clear()
    growthStateRef.current.centerX = canvas.width / 2
    growthStateRef.current.centerY = canvas.height / 2
    growthStateRef.current.points.add(`${Math.floor(canvas.width / 2)},${Math.floor(canvas.height / 2)}`)
    growthStateRef.current.generation = 0
  }

  const exportImage = () => {
    if (!canvasRef.current) return
    
    canvasRef.current.toBlob((blob) => {
      if (!blob) return
      
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `growth-pattern-${Date.now()}.png`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)
    })
  }

  const colorPalettes = [
    { name: 'Matrix', primary: '#000000', secondary: '#00ff00', accent: '#00aa00' },
    { name: 'Coral Reef', primary: '#001a33', secondary: '#ff6b6b', accent: '#4ecdc4' },
    { name: 'Bioluminescent', primary: '#000033', secondary: '#00ffff', accent: '#0088ff' },
    { name: 'Plasma', primary: '#0a0014', secondary: '#ff00ff', accent: '#00ffff' },
    { name: 'Golden Hour', primary: '#1a0f00', secondary: '#ffaa00', accent: '#ff6600' },
    { name: 'Aurora', primary: '#000022', secondary: '#00ff88', accent: '#ff0088' }
  ]

  const patternTypes = [
    { value: OrganicPatternType.GrowthPattern, label: 'Organic Growth' },
    { value: OrganicPatternType.DiffusionLimited, label: 'Diffusion Limited' },
    { value: OrganicPatternType.CrystalGrowth, label: 'Crystal Growth' },
    { value: OrganicPatternType.FlowField, label: 'Flow Field' }
  ]

  return (
    <div className="fixed inset-0 bg-black">
      {/* Full-pane canvas */}
      <canvas
        ref={canvasRef}
        className="absolute inset-0 cursor-crosshair"
        style={{ imageRendering: 'pixelated' }}
      />
      
      {/* Controls overlay */}
      <div className="absolute top-4 left-4 flex items-center gap-2">
        <button
          onClick={() => setIsPlaying(!isPlaying)}
          className="p-3 bg-white/10 backdrop-blur-sm rounded-lg hover:bg-white/20 transition-colors text-white"
          title={isPlaying ? 'Pause' : 'Play'}
        >
          {isPlaying ? <Pause className="h-5 w-5" /> : <Play className="h-5 w-5" />}
        </button>
        
        <button
          onClick={reset}
          className="p-3 bg-white/10 backdrop-blur-sm rounded-lg hover:bg-white/20 transition-colors text-white"
          title="Reset"
        >
          <RotateCcw className="h-5 w-5" />
        </button>
        
        <button
          onClick={exportImage}
          className="p-3 bg-white/10 backdrop-blur-sm rounded-lg hover:bg-white/20 transition-colors text-white"
          title="Export Image"
        >
          <Download className="h-5 w-5" />
        </button>
        
        <button
          onClick={() => setShowSettings(!showSettings)}
          className="p-3 bg-white/10 backdrop-blur-sm rounded-lg hover:bg-white/20 transition-colors text-white"
          title="Settings"
        >
          <Settings className="h-5 w-5" />
        </button>
      </div>
      
      {/* Info overlay */}
      <div className="absolute top-4 right-4 text-white/60 text-sm">
        <div>Generation: {growthStateRef.current.generation}</div>
        <div>Points: {growthStateRef.current.points.size}</div>
        {settings.interactive && <div>Click to add growth seeds</div>}
      </div>
      
      {/* Settings panel */}
      {showSettings && (
        <div className="absolute top-20 left-4 w-80 bg-black/80 backdrop-blur-md rounded-lg p-4 text-white">
          <h3 className="font-semibold mb-4 flex items-center gap-2">
            <Zap className="h-4 w-4" />
            Growth Settings
          </h3>
          
          {/* Pattern Type */}
          <div className="mb-4">
            <label className="text-sm mb-1 block">Pattern Type</label>
            <select
              value={settings.type}
              onChange={(e) => setSettings({ ...settings, type: e.target.value as OrganicPatternType })}
              className="w-full p-2 rounded bg-white/10 border border-white/20"
            >
              {patternTypes.map(type => (
                <option key={type.value} value={type.value}>{type.label}</option>
              ))}
            </select>
          </div>
          
          {/* Growth Rate */}
          <div className="mb-4">
            <label className="text-sm mb-1 block">Growth Rate</label>
            <input
              type="range"
              min="0.001"
              max="0.1"
              step="0.001"
              value={settings.growthRate}
              onChange={(e) => setSettings({ ...settings, growthRate: parseFloat(e.target.value) })}
              className="w-full"
            />
            <span className="text-xs">{(settings.growthRate * 100).toFixed(1)}%</span>
          </div>
          
          {/* Speed */}
          <div className="mb-4">
            <label className="text-sm mb-1 block">Animation Speed</label>
            <input
              type="range"
              min="0.1"
              max="5"
              step="0.1"
              value={settings.speed}
              onChange={(e) => setSettings({ ...settings, speed: parseFloat(e.target.value) })}
              className="w-full"
            />
            <span className="text-xs">{settings.speed.toFixed(1)}x</span>
          </div>
          
          {/* Interactive Mode */}
          <div className="mb-4">
            <label className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={settings.interactive}
                onChange={(e) => setSettings({ ...settings, interactive: e.target.checked })}
                className="rounded"
              />
              <MousePointer className="h-4 w-4" />
              <span className="text-sm">Interactive Mode</span>
            </label>
          </div>
          
          {/* Auto Growth */}
          <div className="mb-4">
            <label className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={settings.autoGrowth}
                onChange={(e) => setSettings({ ...settings, autoGrowth: e.target.checked })}
                className="rounded"
              />
              <Maximize2 className="h-4 w-4" />
              <span className="text-sm">Auto Growth</span>
            </label>
          </div>
          
          {/* Color Palettes */}
          <div className="mb-4">
            <label className="text-sm mb-2 block flex items-center gap-2">
              <Palette className="h-4 w-4" />
              Color Palettes
            </label>
            <div className="grid grid-cols-2 gap-2">
              {colorPalettes.map(palette => (
                <button
                  key={palette.name}
                  onClick={() => setSettings({
                    ...settings,
                    primaryColor: palette.primary,
                    secondaryColor: palette.secondary,
                    accentColor: palette.accent
                  })}
                  className="p-2 rounded bg-white/10 hover:bg-white/20 transition-colors text-xs"
                >
                  <div className="flex gap-1 mb-1">
                    <div className="w-4 h-4 rounded" style={{ backgroundColor: palette.primary }} />
                    <div className="w-4 h-4 rounded" style={{ backgroundColor: palette.secondary }} />
                    <div className="w-4 h-4 rounded" style={{ backgroundColor: palette.accent }} />
                  </div>
                  {palette.name}
                </button>
              ))}
            </div>
          </div>
          
          {/* Custom Colors */}
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <label className="text-sm flex-1">Background</label>
              <input
                type="color"
                value={settings.primaryColor}
                onChange={(e) => setSettings({ ...settings, primaryColor: e.target.value })}
                className="w-20 h-8 rounded cursor-pointer"
              />
            </div>
            <div className="flex items-center gap-2">
              <label className="text-sm flex-1">Primary</label>
              <input
                type="color"
                value={settings.secondaryColor}
                onChange={(e) => setSettings({ ...settings, secondaryColor: e.target.value })}
                className="w-20 h-8 rounded cursor-pointer"
              />
            </div>
            <div className="flex items-center gap-2">
              <label className="text-sm flex-1">Accent</label>
              <input
                type="color"
                value={settings.accentColor}
                onChange={(e) => setSettings({ ...settings, accentColor: e.target.value })}
                className="w-20 h-8 rounded cursor-pointer"
              />
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
import React, { useState, useEffect } from 'react'
import { X, ChevronLeft, ChevronRight, Sliders, Grid3x3, Wand2, Layers, Share2, Download, Upload, Plus, Settings, Search, Clock, Tag, Filter } from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'
import { CustomPattern, PatternCombination } from '../../types/graphics'
import { PatternBuilder } from './PatternBuilder'
import { PatternCombiner } from './PatternCombiner'
import { PatternStorageService } from '../../services/PatternStorageService'
import { PatternType } from '../../graphics/patterns/CulturalPatternGenerator'

interface Pattern {
  id: string
  name: string
  category: string
  description: string
  preview: string
  parameters: PatternParameter[]
}

interface PatternParameter {
  name: string
  type: 'range' | 'color' | 'select'
  min?: number
  max?: number
  value: number | string
  options?: string[]
}

const patterns: Pattern[] = [
  // E2E Test Required Patterns (9 types)
  {
    id: 'flow-fields',
    name: 'Flow Fields',
    category: 'generative',
    description: 'Dynamic flow field patterns with particle movement',
    preview: '🌀',
    parameters: [
      { name: 'Particle Count', type: 'range', min: 100, max: 2000, value: 500 },
      { name: 'Flow Strength', type: 'range', min: 0.1, max: 2, value: 1 },
      { name: 'Speed', type: 'range', min: 0.5, max: 5, value: 2 }
    ]
  },
  {
    id: 'waves',
    name: 'Waves',
    category: 'natural',
    description: 'Flowing wave patterns with customizable amplitude and frequency',
    preview: '〰️',
    parameters: [
      { name: 'Amplitude', type: 'range', min: 10, max: 100, value: 50 },
      { name: 'Frequency', type: 'range', min: 0.1, max: 2, value: 0.5 },
      { name: 'Phase', type: 'range', min: 0, max: 360, value: 0 }
    ]
  },
  {
    id: 'growth',
    name: 'Growth',
    category: 'organic',
    description: 'Organic growth patterns inspired by natural systems',
    preview: '🌱',
    parameters: [
      { name: 'Iterations', type: 'range', min: 3, max: 10, value: 6 },
      { name: 'Branching Factor', type: 'range', min: 2, max: 5, value: 3 },
      { name: 'Growth Rate', type: 'range', min: 0.5, max: 2, value: 1.2 }
    ]
  },
  {
    id: 'truchet',
    name: 'Truchet',
    category: 'geometric',
    description: 'Truchet tile patterns with random rotation',
    preview: '◐',
    parameters: [
      { name: 'Tile Size', type: 'range', min: 20, max: 100, value: 50 },
      { name: 'Randomness', type: 'range', min: 0, max: 1, value: 0.5 },
      { name: 'Style', type: 'select', value: 'curved', options: ['curved', 'straight', 'diagonal'] }
    ]
  },
  {
    id: 'reaction',
    name: 'Reaction',
    category: 'simulation',
    description: 'Reaction-diffusion patterns mimicking chemical processes',
    preview: '🧬',
    parameters: [
      { name: 'Diffusion Rate A', type: 'range', min: 0.5, max: 2, value: 1 },
      { name: 'Diffusion Rate B', type: 'range', min: 0.1, max: 1, value: 0.5 },
      { name: 'Feed Rate', type: 'range', min: 0.01, max: 0.1, value: 0.055 }
    ]
  },
  {
    id: 'voronoi',
    name: 'Voronoi',
    category: 'mathematical',
    description: 'Voronoi diagrams with customizable seed points',
    preview: '🔷',
    parameters: [
      { name: 'Point Count', type: 'range', min: 10, max: 200, value: 50 },
      { name: 'Cell Style', type: 'select', value: 'filled', options: ['filled', 'outlined', 'gradient'] },
      { name: 'Relaxation', type: 'range', min: 0, max: 5, value: 2 }
    ]
  },
  {
    id: 'maze',
    name: 'Maze',
    category: 'algorithmic',
    description: 'Procedural maze generation with various algorithms',
    preview: '🗺️',
    parameters: [
      { name: 'Cell Size', type: 'range', min: 10, max: 50, value: 20 },
      { name: 'Algorithm', type: 'select', value: 'recursive', options: ['recursive', 'prim', 'kruskal'] },
      { name: 'Complexity', type: 'range', min: 0.1, max: 1, value: 0.6 }
    ]
  },
  {
    id: 'l-systems',
    name: 'L-Systems',
    category: 'fractal',
    description: 'Lindenmayer systems for fractal plant-like structures',
    preview: '🌿',
    parameters: [
      { name: 'Iterations', type: 'range', min: 3, max: 8, value: 5 },
      { name: 'Angle', type: 'range', min: 15, max: 90, value: 25 },
      { name: 'Length', type: 'range', min: 5, max: 20, value: 10 }
    ]
  },
  {
    id: 'circles',
    name: 'Circles',
    category: 'geometric',
    description: 'Circle packing and arrangements with various sizes',
    preview: '⭕',
    parameters: [
      { name: 'Circle Count', type: 'range', min: 10, max: 500, value: 100 },
      { name: 'Size Variation', type: 'range', min: 0.1, max: 2, value: 1 },
      { name: 'Packing', type: 'select', value: 'random', options: ['random', 'grid', 'hexagonal'] }
    ]
  },
  // Original Cultural Patterns
  {
    id: 'seigaiha',
    name: 'Seigaiha (Blue Sea Waves)',
    category: 'japanese',
    description: 'Traditional Japanese pattern representing waves and good fortune',
    preview: '🌊',
    parameters: [
      { name: 'Scale', type: 'range', min: 0.5, max: 3, value: 1 },
      { name: 'Wave Height', type: 'range', min: 0.5, max: 2, value: 1 },
      { name: 'Primary Color', type: 'color', value: '#1e40af' },
      { name: 'Secondary Color', type: 'color', value: '#60a5fa' }
    ]
  },
  {
    id: 'asanoha',
    name: 'Asanoha (Hemp Leaf)',
    category: 'japanese',
    description: 'Geometric pattern symbolizing growth and protection',
    preview: '⬡',
    parameters: [
      { name: 'Size', type: 'range', min: 10, max: 100, value: 40 },
      { name: 'Line Width', type: 'range', min: 1, max: 5, value: 2 },
      { name: 'Color', type: 'color', value: '#059669' }
    ]
  },
  {
    id: 'celtic-knot',
    name: 'Celtic Knot',
    category: 'celtic',
    description: 'Interwoven patterns representing eternity and interconnection',
    preview: '🔗',
    parameters: [
      { name: 'Complexity', type: 'range', min: 3, max: 8, value: 5 },
      { name: 'Thickness', type: 'range', min: 2, max: 10, value: 4 },
      { name: 'Style', type: 'select', value: 'traditional', options: ['traditional', 'modern', 'rounded'] }
    ]
  },
  {
    id: 'islamic-geometric',
    name: 'Islamic Geometric',
    category: 'islamic',
    description: 'Mathematical patterns reflecting divine perfection',
    preview: '✦',
    parameters: [
      { name: 'Sides', type: 'range', min: 6, max: 12, value: 8 },
      { name: 'Layers', type: 'range', min: 1, max: 5, value: 3 },
      { name: 'Rotation', type: 'range', min: 0, max: 360, value: 0 }
    ]
  },
  {
    id: 'aztec-step',
    name: 'Aztec Step Pattern',
    category: 'aztec',
    description: 'Stepped geometric patterns from Mesoamerican culture',
    preview: '▨',
    parameters: [
      { name: 'Steps', type: 'range', min: 3, max: 10, value: 5 },
      { name: 'Width', type: 'range', min: 20, max: 100, value: 50 }
    ]
  }
]

export function PatternSelector() {
  const [isOpen, setIsOpen] = useState(false)
  const [selectedPattern, setSelectedPattern] = useState<Pattern | null>(null)
  const [activeCategory, setActiveCategory] = useState('all')
  const [activeTab, setActiveTab] = useState<'browse' | 'custom' | 'combine'>('browse')
  const [customPatterns, setCustomPatterns] = useState<CustomPattern[]>([])
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedTags, setSelectedTags] = useState<string[]>([])
  const [showBuilder, setShowBuilder] = useState(false)
  const [showCombiner, setShowCombiner] = useState(false)
  const [builderPattern, setBuilderPattern] = useState<CustomPattern | null>(null)
  const [recentPatterns, setRecentPatterns] = useState<CustomPattern[]>([])
  const [storageStats, setStorageStats] = useState<any>(null)

  const categories = [
    { id: 'all', name: 'All Patterns' },
    { id: 'generative', name: 'Generative' },
    { id: 'natural', name: 'Natural' },
    { id: 'organic', name: 'Organic' },
    { id: 'geometric', name: 'Geometric' },
    { id: 'simulation', name: 'Simulation' },
    { id: 'mathematical', name: 'Mathematical' },
    { id: 'algorithmic', name: 'Algorithmic' },
    { id: 'fractal', name: 'Fractal' },
    { id: 'japanese', name: 'Japanese' },
    { id: 'celtic', name: 'Celtic' },
    { id: 'islamic', name: 'Islamic' },
    { id: 'aztec', name: 'Aztec' },
    { id: 'custom', name: 'Custom' }
  ]

  const filteredPatterns = activeCategory === 'all' 
    ? patterns 
    : patterns.filter(p => p.category === activeCategory)

  // Load custom patterns and stats
  useEffect(() => {
    loadCustomPatterns()
    loadRecentPatterns()
    loadStorageStats()
  }, [])

  // Handle URL sharing
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search)
    const shareId = urlParams.get('share')
    
    if (shareId) {
      const sharedPattern = PatternStorageService.loadPatternFromShare(shareId)
      if (sharedPattern) {
        setCustomPatterns(prev => [sharedPattern, ...prev])
        setActiveTab('custom')
        setIsOpen(true)
      }
    }
  }, [])

  const loadCustomPatterns = () => {
    const patterns = PatternStorageService.getAllPatterns()
    setCustomPatterns(patterns)
  }

  const loadRecentPatterns = () => {
    const recent = PatternStorageService.getRecentPatterns(5)
    setRecentPatterns(recent)
  }

  const loadStorageStats = () => {
    const stats = PatternStorageService.getStorageStats()
    setStorageStats(stats)
  }

  const filterCustomPatterns = () => {
    let filtered = customPatterns

    if (searchQuery) {
      filtered = PatternStorageService.searchPatterns(searchQuery)
    }

    if (selectedTags.length > 0) {
      filtered = PatternStorageService.getPatternsByTags(selectedTags)
    }

    return filtered
  }

  const applyPattern = () => {
    if (!selectedPattern) return
    
    // TODO: Apply pattern to canvas with current parameters
    console.log('Applying pattern:', selectedPattern)
    setIsOpen(false)
  }

  const handlePatternSave = (pattern: CustomPattern) => {
    loadCustomPatterns()
    loadRecentPatterns()
    loadStorageStats()
    setShowBuilder(false)
    setActiveTab('custom')
  }

  const handlePatternEdit = (pattern: CustomPattern) => {
    setBuilderPattern(pattern)
    setShowBuilder(true)
  }

  const handlePatternShare = (pattern: CustomPattern) => {
    const shareUrl = PatternStorageService.generateShareableUrl(pattern)
    navigator.clipboard.writeText(shareUrl)
    // Show success message
    console.log('Pattern shared:', shareUrl)
  }

  const handlePatternDelete = (patternId: string) => {
    PatternStorageService.deletePattern(patternId)
    loadCustomPatterns()
    loadRecentPatterns()
    loadStorageStats()
  }

  const exportPatterns = () => {
    const data = PatternStorageService.exportPatterns()
    const blob = new Blob([data], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = 'genshi-patterns.json'
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  const importPatterns = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return

    const reader = new FileReader()
    reader.onload = (e) => {
      const content = e.target?.result as string
      const result = PatternStorageService.importPatterns(content)
      
      if (result.success) {
        loadCustomPatterns()
        loadRecentPatterns()
        loadStorageStats()
        console.log(`Imported ${result.imported} patterns`)
      } else {
        console.error('Import failed:', result.errors)
      }
    }
    reader.readAsText(file)
  }

  const getAllTags = () => {
    const tags = new Set<string>()
    customPatterns.forEach(pattern => {
      pattern.tags.forEach(tag => tags.add(tag))
    })
    return Array.from(tags)
  }

  const toggleTag = (tag: string) => {
    setSelectedTags(prev => 
      prev.includes(tag) 
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    )
  }

  return (
    <>
      {/* Pattern button */}
      <button
        onClick={() => setIsOpen(true)}
        className="absolute bottom-4 right-4 px-4 py-2 bg-primary text-primary-foreground rounded-lg shadow-lg hover:bg-primary/90 transition-colors flex items-center gap-2"
        data-testid="pattern-selector"
      >
        <Grid3x3 className="h-5 w-5" />
        <span>Patterns</span>
      </button>

      {/* Pattern selector modal */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={(e) => {
              if (e.target === e.currentTarget) setIsOpen(false)
            }}
          >
            <motion.div
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.9, opacity: 0 }}
              className="bg-card rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] flex flex-col"
              data-testid="pattern-library"
            >
              {/* Header */}
              <div className="p-6 border-b border-border flex items-center justify-between">
                <h2 className="text-2xl font-bold">Pattern Library</h2>
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => setShowBuilder(true)}
                    className="px-4 py-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors flex items-center gap-2"
                  >
                    <Wand2 className="h-4 w-4" />
                    Create
                  </button>
                  <button
                    onClick={() => setShowCombiner(true)}
                    className="px-4 py-2 bg-secondary text-secondary-foreground rounded-lg hover:bg-secondary/90 transition-colors flex items-center gap-2"
                  >
                    <Layers className="h-4 w-4" />
                    Combine
                  </button>
                  <button
                    onClick={exportPatterns}
                    className="p-2 hover:bg-accent rounded-md transition-colors"
                    title="Export Patterns"
                  >
                    <Download className="h-4 w-4" />
                  </button>
                  <label className="p-2 hover:bg-accent rounded-md transition-colors cursor-pointer" title="Import Patterns">
                    <Upload className="h-4 w-4" />
                    <input
                      type="file"
                      accept=".json"
                      onChange={importPatterns}
                      className="hidden"
                    />
                  </label>
                  <button
                    onClick={() => setIsOpen(false)}
                    className="p-2 hover:bg-accent rounded-md transition-colors"
                  >
                    <X className="h-5 w-5" />
                  </button>
                </div>
              </div>

              {/* Tabs */}
              <div className="flex border-b border-border">
                {[
                  { id: 'browse', label: 'Browse', icon: Grid3x3 },
                  { id: 'custom', label: 'Custom', icon: Wand2 },
                  { id: 'combine', label: 'Combine', icon: Layers }
                ].map(tab => (
                  <button
                    key={tab.id}
                    onClick={() => setActiveTab(tab.id as any)}
                    className={`flex items-center gap-2 px-6 py-3 text-sm font-medium transition-colors ${
                      activeTab === tab.id
                        ? 'border-b-2 border-primary text-primary bg-primary/10'
                        : 'text-muted-foreground hover:text-foreground'
                    }`}
                  >
                    <tab.icon className="h-4 w-4" />
                    {tab.label}
                  </button>
                ))}
              </div>

              {/* Content */}
              <div className="flex-1 flex overflow-hidden">
                {/* Sidebar */}
                <div className="w-80 border-r border-border p-6 overflow-y-auto">
                  {activeTab === 'browse' && (
                    <>
                      <div className="mb-6">
                        <h3 className="text-lg font-semibold mb-4">Categories</h3>
                        <div className="grid grid-cols-2 gap-2">
                          {categories.slice(0, -1).map((cat) => (
                            <button
                              key={cat.id}
                              onClick={() => setActiveCategory(cat.id)}
                              className={`px-3 py-2 rounded-md text-sm font-medium transition-colors ${
                                activeCategory === cat.id
                                  ? 'bg-primary text-primary-foreground'
                                  : 'bg-secondary hover:bg-secondary/80'
                              }`}
                            >
                              {cat.name}
                            </button>
                          ))}
                        </div>
                      </div>

                      <div className="grid grid-cols-2 gap-4">
                        {filteredPatterns.map((pattern) => (
                          <button
                            key={pattern.id}
                            onClick={() => setSelectedPattern(pattern)}
                            className={`p-4 rounded-lg border-2 transition-all ${
                              selectedPattern?.id === pattern.id
                                ? 'border-primary bg-primary/10'
                                : 'border-border hover:border-primary/50'
                            }`}
                            data-pattern={pattern.name}
                          >
                            <div className="text-4xl mb-2">{pattern.preview}</div>
                            <h3 className="font-semibold text-sm">{pattern.name}</h3>
                            <p className="text-xs text-muted-foreground mt-1">
                              {pattern.description}
                            </p>
                          </button>
                        ))}
                      </div>
                    </>
                  )}

                  {activeTab === 'custom' && (
                    <>
                      <div className="mb-6">
                        <div className="flex items-center gap-2 mb-4">
                          <Search className="h-4 w-4" />
                          <input
                            type="text"
                            placeholder="Search patterns..."
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            className="flex-1 p-2 rounded border border-border bg-background"
                          />
                        </div>

                        <div className="mb-4">
                          <h4 className="text-sm font-medium mb-2">Tags</h4>
                          <div className="flex flex-wrap gap-1">
                            {getAllTags().map(tag => (
                              <button
                                key={tag}
                                onClick={() => toggleTag(tag)}
                                className={`px-2 py-1 rounded-full text-xs transition-colors ${
                                  selectedTags.includes(tag)
                                    ? 'bg-primary text-primary-foreground'
                                    : 'bg-secondary hover:bg-secondary/80'
                                }`}
                              >
                                {tag}
                              </button>
                            ))}
                          </div>
                        </div>

                        {recentPatterns.length > 0 && (
                          <div className="mb-4">
                            <h4 className="text-sm font-medium mb-2 flex items-center gap-2">
                              <Clock className="h-4 w-4" />
                              Recent
                            </h4>
                            <div className="space-y-2">
                              {recentPatterns.map(pattern => (
                                <button
                                  key={pattern.id}
                                  onClick={() => handlePatternEdit(pattern)}
                                  className="w-full p-2 text-left rounded border border-border hover:border-primary/50 transition-colors"
                                >
                                  <div className="font-medium text-sm">{pattern.name}</div>
                                  <div className="text-xs text-muted-foreground">
                                    {pattern.modifiedAt.toLocaleDateString()}
                                  </div>
                                </button>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>

                      <div className="grid grid-cols-1 gap-4">
                        {filterCustomPatterns().map((pattern) => (
                          <div
                            key={pattern.id}
                            className="p-4 rounded-lg border border-border hover:border-primary/50 transition-colors"
                          >
                            <div className="flex items-center justify-between mb-2">
                              <h3 className="font-semibold text-sm">{pattern.name}</h3>
                              <div className="flex items-center gap-1">
                                <button
                                  onClick={() => handlePatternEdit(pattern)}
                                  className="p-1 hover:bg-accent rounded"
                                  title="Edit"
                                >
                                  <Settings className="h-3 w-3" />
                                </button>
                                <button
                                  onClick={() => handlePatternShare(pattern)}
                                  className="p-1 hover:bg-accent rounded"
                                  title="Share"
                                >
                                  <Share2 className="h-3 w-3" />
                                </button>
                                <button
                                  onClick={() => handlePatternDelete(pattern.id)}
                                  className="p-1 hover:bg-accent rounded text-red-500"
                                  title="Delete"
                                >
                                  <X className="h-3 w-3" />
                                </button>
                              </div>
                            </div>
                            <p className="text-xs text-muted-foreground mb-2">{pattern.description}</p>
                            <div className="flex flex-wrap gap-1">
                              {pattern.tags.map(tag => (
                                <span
                                  key={tag}
                                  className="px-2 py-1 bg-secondary rounded-full text-xs"
                                >
                                  {tag}
                                </span>
                              ))}
                            </div>
                          </div>
                        ))}
                      </div>

                      {customPatterns.length === 0 && (
                        <div className="text-center py-8 text-muted-foreground">
                          <Wand2 className="h-12 w-12 mx-auto mb-3 opacity-50" />
                          <p>No custom patterns yet.</p>
                          <p className="text-sm">Create your first pattern!</p>
                        </div>
                      )}
                    </>
                  )}
                </div>

                {/* Main content */}
                <div className="flex-1 p-6 overflow-y-auto">
                  {activeTab === 'browse' && selectedPattern && (
                    <>
                      <h3 className="text-lg font-semibold mb-4">
                        Customize {selectedPattern.name}
                      </h3>
                      
                      <div className="space-y-4">
                        {selectedPattern.parameters.map((param) => (
                          <div key={param.name}>
                            <label className="text-sm font-medium mb-2 block">
                              {param.name}
                            </label>
                            
                            {param.type === 'range' && (
                              <div className="flex items-center gap-3">
                                <input
                                  type="range"
                                  min={param.min}
                                  max={param.max}
                                  value={param.value as number}
                                  className="flex-1"
                                />
                                <span className="text-sm w-12 text-right">
                                  {param.value}
                                </span>
                              </div>
                            )}
                            
                            {param.type === 'color' && (
                              <input
                                type="color"
                                value={param.value as string}
                                className="w-full h-10 rounded cursor-pointer"
                              />
                            )}
                            
                            {param.type === 'select' && (
                              <select
                                value={param.value as string}
                                className="w-full p-2 rounded border border-border bg-background"
                              >
                                {param.options?.map((opt) => (
                                  <option key={opt} value={opt}>
                                    {opt}
                                  </option>
                                ))}
                              </select>
                            )}
                          </div>
                        ))}
                      </div>

                      <div className="mt-6 p-8 bg-gray-100 rounded-lg flex items-center justify-center">
                        <div className="text-6xl">{selectedPattern.preview}</div>
                      </div>

                      <button
                        onClick={applyPattern}
                        className="w-full mt-6 py-3 bg-primary text-primary-foreground rounded-lg font-semibold hover:bg-primary/90 transition-colors"
                      >
                        Apply Pattern
                      </button>
                    </>
                  )}

                  {activeTab === 'browse' && !selectedPattern && (
                    <div className="h-full flex items-center justify-center text-muted-foreground">
                      <div className="text-center">
                        <Sliders className="h-12 w-12 mx-auto mb-3 opacity-50" />
                        <p>Select a pattern to customize</p>
                      </div>
                    </div>
                  )}

                  {activeTab === 'custom' && (
                    <div className="space-y-6">
                      <div className="bg-secondary/50 rounded-lg p-4">
                        <h4 className="font-semibold mb-2">Storage Usage</h4>
                        {storageStats && (
                          <div className="space-y-2">
                            <div className="flex justify-between text-sm">
                              <span>Patterns: {storageStats.patterns}</span>
                              <span>Variations: {storageStats.variations}</span>
                            </div>
                            <div className="w-full bg-gray-200 rounded-full h-2">
                              <div 
                                className="bg-primary h-2 rounded-full" 
                                style={{ width: `${Math.min(storageStats.percentUsed, 100)}%` }}
                              />
                            </div>
                            <div className="text-xs text-muted-foreground">
                              {(storageStats.totalSize / 1024).toFixed(1)}KB used
                            </div>
                          </div>
                        )}
                      </div>

                      <div className="text-center">
                        <button
                          onClick={() => setShowBuilder(true)}
                          className="px-6 py-3 bg-primary text-primary-foreground rounded-lg font-semibold hover:bg-primary/90 transition-colors flex items-center gap-2 mx-auto"
                        >
                          <Plus className="h-4 w-4" />
                          Create New Pattern
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Pattern Builder Modal */}
      {showBuilder && (
        <PatternBuilder
          isOpen={showBuilder}
          onClose={() => {
            setShowBuilder(false)
            setBuilderPattern(null)
          }}
          initialPattern={builderPattern || undefined}
          onSave={handlePatternSave}
        />
      )}

      {/* Pattern Combiner Modal */}
      {showCombiner && (
        <div className="fixed inset-0 bg-black/50 z-[60] flex items-center justify-center p-4">
          <div className="bg-card rounded-xl shadow-2xl max-w-7xl w-full max-h-[90vh] flex flex-col">
            <div className="p-6 border-b border-border flex items-center justify-between">
              <h2 className="text-2xl font-bold">Pattern Combiner</h2>
              <button
                onClick={() => setShowCombiner(false)}
                className="p-2 hover:bg-accent rounded-md transition-colors"
              >
                <X className="h-5 w-5" />
              </button>
            </div>
            <div className="flex-1 p-6 overflow-hidden">
              <PatternCombiner
                onCombinationChange={(combination) => {
                  console.log('Combination changed:', combination)
                }}
                width={400}
                height={400}
              />
            </div>
          </div>
        </div>
      )}
    </>
  )
}
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  Play, 
  Pause, 
  RotateCcw, 
  SkipBack, 
  SkipForward, 
  Download,
  Plus
} from 'lucide-react';
import { 
  AnimationConfig, 
  AnimationKeyframe, 
  CustomPattern
} from '../../types/graphics';
import { AdvancedPatternGenerator } from '../../graphics/patterns/AdvancedPatternGenerator';
import { PatternType } from '../../graphics/patterns/CulturalPatternGenerator';

interface PatternAnimationControllerProps {
  pattern: CustomPattern;
  animationConfig: AnimationConfig;
  onAnimationConfigChange: (config: AnimationConfig) => void;
  width: number;
  height: number;
  onFrameGenerated?: (imageData: ImageData) => void;
  className?: string;
}

export function PatternAnimationController({
  pattern,
  animationConfig,
  onAnimationConfigChange,
  width,
  height,
  onFrameGenerated,
  className
}: PatternAnimationControllerProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [playbackSpeed, setPlaybackSpeed] = useState(1);
  const [isLooping, setIsLooping] = useState(true);
  const [exportingGif, setExportingGif] = useState(false);
  
  const animationRef = useRef<number | null>(null);
  const generatorRef = useRef<AdvancedPatternGenerator | null>(null);
  const startTimeRef = useRef<number>(0);
  const timelineRef = useRef<HTMLDivElement>(null);

  // Initialize pattern generator
  useEffect(() => {
    if (!generatorRef.current) {
      generatorRef.current = new AdvancedPatternGenerator();
    }
    
    return () => {
      if (generatorRef.current) {
        generatorRef.current.destroy();
      }
    };
  }, []);

  // Clean up animation on unmount
  useEffect(() => {
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);

  const buildPatternOptions = useCallback(() => {
    const options: any = {
      scale: 1,
      rotation: 0,
      color1: { r: 0, g: 0, b: 0, a: 1 },
      color2: { r: 1, g: 1, b: 1, a: 1 }
    };

    pattern.parameters.forEach(param => {
      if (param.type === 'color') {
        const hex = param.value as string;
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
          options[param.name] = {
            r: parseInt(result[1], 16) / 255,
            g: parseInt(result[2], 16) / 255,
            b: parseInt(result[3], 16) / 255,
            a: 1
          };
        }
      } else {
        options[param.name] = param.value;
      }
    });

    return options;
  }, [pattern.parameters]);

  const interpolateKeyframes = useCallback((time: number) => {
    const normalizedTime = time / animationConfig.duration;
    const keyframes = [...animationConfig.keyframes].sort((a, b) => a.time - b.time);
    
    if (keyframes.length === 0) return buildPatternOptions();
    
    // Handle time outside keyframe range
    if (normalizedTime <= keyframes[0].time) {
      return { ...buildPatternOptions(), ...keyframes[0].parameters };
    }
    if (normalizedTime >= keyframes[keyframes.length - 1].time) {
      return { ...buildPatternOptions(), ...keyframes[keyframes.length - 1].parameters };
    }
    
    // Find surrounding keyframes
    let beforeFrame = keyframes[0];
    let afterFrame = keyframes[keyframes.length - 1];
    
    for (let i = 0; i < keyframes.length - 1; i++) {
      if (normalizedTime >= keyframes[i].time && normalizedTime <= keyframes[i + 1].time) {
        beforeFrame = keyframes[i];
        afterFrame = keyframes[i + 1];
        break;
      }
    }
    
    // Interpolate between keyframes
    const progress = (normalizedTime - beforeFrame.time) / (afterFrame.time - beforeFrame.time);
    const interpolatedParams: any = {};
    
    animationConfig.animatedParams.forEach(param => {
      const beforeValue = beforeFrame.parameters[param];
      const afterValue = afterFrame.parameters[param];
      
      if (typeof beforeValue === 'number' && typeof afterValue === 'number') {
        interpolatedParams[param] = beforeValue + (afterValue - beforeValue) * progress;
      } else if (param.includes('color')) {
        // Handle color interpolation
        if (beforeValue && afterValue) {
          interpolatedParams[param] = {
            r: beforeValue.r + (afterValue.r - beforeValue.r) * progress,
            g: beforeValue.g + (afterValue.g - beforeValue.g) * progress,
            b: beforeValue.b + (afterValue.b - beforeValue.b) * progress,
            a: beforeValue.a + (afterValue.a - beforeValue.a) * progress
          };
        }
      }
    });
    
    return { ...buildPatternOptions(), ...interpolatedParams };
  }, [animationConfig, buildPatternOptions]);

  const generateFrame = useCallback((time: number) => {
    if (!generatorRef.current) return;
    
    const options = interpolateKeyframes(time);
    const imageData = generatorRef.current.generatePattern(
      pattern.basePattern as PatternType,
      width,
      height,
      options
    );
    
    if (onFrameGenerated) {
      onFrameGenerated(imageData);
    }
    
    return imageData;
  }, [interpolateKeyframes, pattern.basePattern, width, height, onFrameGenerated]);

  const animate = useCallback((timestamp: number) => {
    if (!startTimeRef.current) {
      startTimeRef.current = timestamp;
    }
    
    const elapsed = (timestamp - startTimeRef.current) / 1000 * playbackSpeed;
    let animationTime = elapsed;
    
    // Handle direction
    if (animationConfig.direction === 'reverse') {
      animationTime = animationConfig.duration - (elapsed % animationConfig.duration);
    } else if (animationConfig.direction === 'alternate') {
      const cycle = Math.floor(elapsed / animationConfig.duration);
      const cycleTime = elapsed % animationConfig.duration;
      animationTime = cycle % 2 === 0 ? cycleTime : animationConfig.duration - cycleTime;
    } else {
      animationTime = elapsed % animationConfig.duration;
    }
    
    setCurrentTime(animationTime);
    generateFrame(animationTime);
    
    // Check if animation should continue
    if (isPlaying && (isLooping || elapsed < animationConfig.duration)) {
      animationRef.current = requestAnimationFrame(animate);
    } else if (!isLooping && elapsed >= animationConfig.duration) {
      setIsPlaying(false);
    }
  }, [isPlaying, playbackSpeed, animationConfig, isLooping, generateFrame]);

  const play = useCallback(() => {
    if (isPlaying) return;
    
    setIsPlaying(true);
    startTimeRef.current = 0;
    animationRef.current = requestAnimationFrame(animate);
  }, [isPlaying, animate]);

  const pause = useCallback(() => {
    setIsPlaying(false);
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, []);

  const reset = useCallback(() => {
    pause();
    setCurrentTime(0);
    generateFrame(0);
  }, [pause, generateFrame]);

  const seekTo = useCallback((time: number) => {
    const clampedTime = Math.max(0, Math.min(animationConfig.duration, time));
    setCurrentTime(clampedTime);
    generateFrame(clampedTime);
  }, [animationConfig.duration, generateFrame]);

  const handleTimelineClick = useCallback((e: React.MouseEvent) => {
    if (!timelineRef.current) return;
    
    const rect = timelineRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const percentage = x / rect.width;
    const time = percentage * animationConfig.duration;
    
    seekTo(time);
  }, [animationConfig.duration, seekTo]);

  const addKeyframe = useCallback((time: number) => {
    const normalizedTime = time / animationConfig.duration;
    const currentOptions = buildPatternOptions();
    
    const newKeyframe: AnimationKeyframe = {
      time: normalizedTime,
      parameters: {}
    };
    
    // Add current values for animated parameters
    animationConfig.animatedParams.forEach(param => {
      newKeyframe.parameters[param] = currentOptions[param];
    });
    
    const updatedKeyframes = [...animationConfig.keyframes, newKeyframe]
      .sort((a, b) => a.time - b.time);
    
    onAnimationConfigChange({
      ...animationConfig,
      keyframes: updatedKeyframes
    });
  }, [animationConfig, buildPatternOptions, onAnimationConfigChange]);

  const exportAsGif = useCallback(async () => {
    setExportingGif(true);
    
    try {
      // This is a simplified version - you'd need to implement actual GIF encoding
      const frames: ImageData[] = [];
      const frameCount = Math.ceil(animationConfig.duration * 30); // 30 FPS
      
      for (let i = 0; i < frameCount; i++) {
        const time = (i / frameCount) * animationConfig.duration;
        const frame = generateFrame(time);
        if (frame) frames.push(frame);
      }
      
      // Here you would use a GIF encoder library like gif.js
      console.log('Generated', frames.length, 'frames for GIF export');
      
      // For now, just export the first frame as PNG
      if (frames.length > 0) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.putImageData(frames[0], 0, 0);
          const link = document.createElement('a');
          link.download = `${pattern.name}-animated.png`;
          link.href = canvas.toDataURL();
          link.click();
        }
      }
    } catch (error) {
      console.error('Failed to export GIF:', error);
    } finally {
      setExportingGif(false);
    }
  }, [animationConfig, generateFrame, width, height, pattern.name]);

  const progress = animationConfig.duration > 0 ? currentTime / animationConfig.duration : 0;

  return (
    <div className={`bg-card border border-border rounded-lg p-4 ${className}`}>
      {/* Timeline */}
      <div className="mb-4">
        <div className="flex items-center justify-between mb-2">
          <span className="text-sm font-medium">Timeline</span>
          <span className="text-xs text-muted-foreground">
            {currentTime.toFixed(2)}s / {animationConfig.duration.toFixed(2)}s
          </span>
        </div>
        
        <div
          ref={timelineRef}
          className="relative h-8 bg-secondary rounded cursor-pointer"
          onClick={handleTimelineClick}
        >
          {/* Progress bar */}
          <div
            className="absolute top-0 left-0 h-full bg-primary rounded"
            style={{ width: `${progress * 100}%` }}
          />
          
          {/* Keyframes */}
          {animationConfig.keyframes.map((keyframe, index) => (
            <div
              key={index}
              className="absolute top-0 w-1 h-full bg-yellow-500 cursor-pointer"
              style={{ left: `${keyframe.time * 100}%` }}
              title={`Keyframe at ${(keyframe.time * animationConfig.duration).toFixed(2)}s`}
            />
          ))}
          
          {/* Playhead */}
          <div
            className="absolute top-0 w-0.5 h-full bg-red-500 z-10"
            style={{ left: `${progress * 100}%` }}
          />
        </div>
      </div>

      {/* Controls */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <button
            onClick={reset}
            className="p-2 hover:bg-accent rounded-md transition-colors"
            title="Reset"
          >
            <RotateCcw className="h-4 w-4" />
          </button>
          
          <button
            onClick={() => seekTo(currentTime - 0.1)}
            className="p-2 hover:bg-accent rounded-md transition-colors"
            title="Step Back"
          >
            <SkipBack className="h-4 w-4" />
          </button>
          
          <button
            onClick={isPlaying ? pause : play}
            className="p-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors"
            title={isPlaying ? 'Pause' : 'Play'}
          >
            {isPlaying ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
          </button>
          
          <button
            onClick={() => seekTo(currentTime + 0.1)}
            className="p-2 hover:bg-accent rounded-md transition-colors"
            title="Step Forward"
          >
            <SkipForward className="h-4 w-4" />
          </button>
        </div>

        <div className="flex items-center gap-2">
          <div className="flex items-center gap-1">
            <span className="text-xs">Speed:</span>
            <select
              value={playbackSpeed}
              onChange={(e) => setPlaybackSpeed(parseFloat(e.target.value))}
              className="text-xs p-1 rounded border border-border bg-background"
            >
              <option value={0.25}>0.25x</option>
              <option value={0.5}>0.5x</option>
              <option value={1}>1x</option>
              <option value={2}>2x</option>
              <option value={4}>4x</option>
            </select>
          </div>
          
          <button
            onClick={() => setIsLooping(!isLooping)}
            className={`p-2 rounded-md transition-colors ${
              isLooping ? 'bg-primary text-primary-foreground' : 'hover:bg-accent'
            }`}
            title="Loop"
          >
            Loop
          </button>
          
          <button
            onClick={() => addKeyframe(currentTime)}
            className="p-2 hover:bg-accent rounded-md transition-colors"
            title="Add Keyframe"
          >
            <Plus className="h-4 w-4" />
          </button>
          
          <button
            onClick={exportAsGif}
            disabled={exportingGif}
            className="p-2 hover:bg-accent rounded-md transition-colors"
            title="Export as GIF"
          >
            <Download className="h-4 w-4" />
          </button>
        </div>
      </div>
    </div>
  );
}
import React, { useState, useRef, useEffect } from 'react'
import { Download, Shuffle } from 'lucide-react'

interface PatternSettings {
  type: 'ichimatsu' | 'seigaiha' | 'asanoha' | 'shippo' | 'yamaji'
  size: number
  density: number
  primaryColor: string
  secondaryColor: string
  accentColor: string
  rotation: number
  opacity: number
}

const COLOR_PALETTES = [
  { name: 'Traditional Blue', colors: ['#4a90e2', '#f5f5f5', '#feca57'] },
  { name: 'Sakura Spring', colors: ['#ffb7c5', '#fff0f5', '#ff69b4'] },
  { name: 'Autumn Maple', colors: ['#dc143c', '#fff8dc', '#ff8c00'] },
  { name: 'Zen Garden', colors: ['#228b22', '#f0fff0', '#8b4513'] },
  { name: 'Night Sky', colors: ['#191970', '#f8f8ff', '#ffd700'] },
]

export function ParametricPatternEditor() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [settings, setSettings] = useState<PatternSettings>({
    type: 'ichimatsu',
    size: 30,
    density: 1.0,
    primaryColor: '#4a90e2',
    secondaryColor: '#f5f5f5',
    accentColor: '#feca57',
    rotation: 0,
    opacity: 100
  })

  // Update pattern whenever settings change
  useEffect(() => {
    updatePattern()
  }, [settings])

  const updatePattern = () => {
    const canvas = canvasRef.current
    if (!canvas) return
    
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    
    // Save context for transformations
    ctx.save()
    
    // Apply rotation
    if (settings.rotation !== 0) {
      ctx.translate(canvas.width / 2, canvas.height / 2)
      ctx.rotate(settings.rotation * Math.PI / 180)
      ctx.translate(-canvas.width / 2, -canvas.height / 2)
    }
    
    // Apply global opacity
    ctx.globalAlpha = settings.opacity / 100
    
    // Draw pattern based on type
    switch(settings.type) {
      case 'ichimatsu':
        drawIchimatsu(ctx, canvas, settings)
        break
      case 'seigaiha':
        drawSeigaiha(ctx, canvas, settings)
        break
      case 'asanoha':
        drawAsanoha(ctx, canvas, settings)
        break
      case 'shippo':
        drawShippo(ctx, canvas, settings)
        break
      case 'yamaji':
        drawYamaji(ctx, canvas, settings)
        break
    }
    
    // Restore context
    ctx.restore()
  }

  const drawIchimatsu = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, settings: PatternSettings) => {
    const size = settings.size * settings.density
    const colors = [settings.primaryColor, settings.secondaryColor]
    
    for (let x = -size; x < canvas.width + size; x += size) {
      for (let y = -size; y < canvas.height + size; y += size) {
        const colorIndex = (Math.floor(x / size) + Math.floor(y / size)) % 2
        ctx.fillStyle = colors[colorIndex]
        ctx.fillRect(x, y, size, size)
      }
    }
  }

  const drawSeigaiha = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, settings: PatternSettings) => {
    const radius = settings.size * settings.density
    const spacing = radius * 2
    
    ctx.strokeStyle = settings.primaryColor
    ctx.lineWidth = 2
    
    for (let x = -radius; x < canvas.width + radius; x += spacing) {
      for (let y = -radius; y < canvas.height + radius; y += spacing) {
        for (let r = 5; r < radius; r += radius / 3) {
          ctx.beginPath()
          ctx.arc(x, y, r, 0, Math.PI)
          ctx.stroke()
        }
      }
    }
  }

  const drawAsanoha = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, settings: PatternSettings) => {
    const size = settings.size * settings.density
    
    ctx.strokeStyle = settings.primaryColor
    ctx.lineWidth = 2
    
    for (let x = -size; x < canvas.width + size; x += size) {
      for (let y = -size; y < canvas.height + size; y += size) {
        // Draw hexagon
        ctx.beginPath()
        for (let i = 0; i < 6; i++) {
          const angle = (i * Math.PI) / 3
          const px = x + size/2 + Math.cos(angle) * size/3
          const py = y + size/2 + Math.sin(angle) * size/3
          
          if (i === 0) {
            ctx.moveTo(px, py)
          } else {
            ctx.lineTo(px, py)
          }
        }
        ctx.closePath()
        ctx.stroke()
        
        // Draw inner lines
        ctx.beginPath()
        ctx.moveTo(x + size/2, y)
        ctx.lineTo(x + size/2, y + size)
        ctx.moveTo(x, y + size/2)
        ctx.lineTo(x + size, y + size/2)
        ctx.stroke()
      }
    }
  }

  const drawShippo = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, settings: PatternSettings) => {
    const size = settings.size * settings.density
    const radius = size / 2
    
    ctx.strokeStyle = settings.primaryColor
    ctx.lineWidth = 2
    
    for (let x = -size; x < canvas.width + size; x += size) {
      for (let y = -size; y < canvas.height + size; y += size) {
        // Draw overlapping circles
        ctx.beginPath()
        ctx.arc(x + size/2, y + size/2, radius, 0, 2 * Math.PI)
        ctx.stroke()
        
        // Fill intersection with accent color
        ctx.fillStyle = settings.accentColor
        ctx.beginPath()
        ctx.arc(x + size/2, y + size/2, radius / 3, 0, 2 * Math.PI)
        ctx.fill()
      }
    }
  }

  const drawYamaji = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, settings: PatternSettings) => {
    const size = settings.size * settings.density
    
    ctx.strokeStyle = settings.primaryColor
    ctx.lineWidth = 2
    
    for (let x = -size; x < canvas.width + size; x += size) {
      for (let y = -size; y < canvas.height + size; y += size) {
        // Draw diagonal lines creating mountain path pattern
        ctx.beginPath()
        ctx.moveTo(x, y)
        ctx.lineTo(x + size, y + size)
        ctx.moveTo(x + size, y)
        ctx.lineTo(x, y + size)
        ctx.stroke()
        
        // Add accent points
        ctx.fillStyle = settings.accentColor
        ctx.beginPath()
        ctx.arc(x + size/2, y + size/2, 2, 0, 2 * Math.PI)
        ctx.fill()
      }
    }
  }

  const exportPattern = (format: 'png' | 'svg') => {
    const canvas = canvasRef.current
    if (!canvas) return

    if (format === 'png') {
      const link = document.createElement('a')
      link.download = `genshi-pattern-${settings.type}-${Date.now()}.png`
      link.href = canvas.toDataURL()
      link.click()
    } else if (format === 'svg') {
      // Create SVG representation
      const svg = createSVGPattern()
      const blob = new Blob([svg], { type: 'image/svg+xml' })
      const url = URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.download = `genshi-pattern-${settings.type}-${Date.now()}.svg`
      link.href = url
      link.click()
      URL.revokeObjectURL(url)
    }
  }

  const createSVGPattern = () => {
    const width = 600
    const height = 600
    
    return `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
    <rect width="${width}" height="${height}" fill="${settings.secondaryColor}"/>
    <g opacity="${settings.opacity / 100}" transform="rotate(${settings.rotation} ${width/2} ${height/2})">
        <!-- Pattern elements would be generated here based on pattern type -->
        <rect x="0" y="0" width="${width}" height="${height}" fill="${settings.primaryColor}" opacity="0.5"/>
    </g>
</svg>`
  }

  const randomizePattern = () => {
    const patterns: PatternSettings['type'][] = ['ichimatsu', 'seigaiha', 'asanoha', 'shippo', 'yamaji']
    const colors = [
      '#4a90e2', '#e74c3c', '#2ecc71', '#9b59b6', '#f39c12',
      '#1abc9c', '#34495e', '#e67e22', '#3498db', '#95a5a6'
    ]
    
    setSettings({
      type: patterns[Math.floor(Math.random() * patterns.length)],
      size: Math.floor(Math.random() * 80) + 20,
      density: Math.random() * 2.5 + 0.5,
      primaryColor: colors[Math.floor(Math.random() * colors.length)],
      secondaryColor: colors[Math.floor(Math.random() * colors.length)],
      accentColor: colors[Math.floor(Math.random() * colors.length)],
      rotation: Math.floor(Math.random() * 360),
      opacity: Math.floor(Math.random() * 90) + 10
    })
  }

  const applyPalette = (palette: typeof COLOR_PALETTES[0]) => {
    setSettings(prev => ({
      ...prev,
      primaryColor: palette.colors[0],
      secondaryColor: palette.colors[1],
      accentColor: palette.colors[2]
    }))
  }

  return (
    <div className="h-full bg-gradient-to-br from-purple-600 via-purple-700 to-indigo-800 p-6 overflow-auto">
      <div className="max-w-7xl mx-auto">
        <h1 className="text-3xl md:text-4xl font-bold text-white text-center mb-8 drop-shadow-lg">
          源始 Genshi Studio - Parametric Pattern Editor
        </h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Controls Panel */}
          <div className="lg:col-span-1">
            <div className="bg-white/10 backdrop-blur-md border border-white/20 rounded-lg p-6">
              <h2 className="text-xl font-semibold text-white mb-6">Pattern Controls</h2>
              
              <div className="space-y-6">
                {/* Pattern Type */}
                <div className="space-y-2">
                  <label className="text-white font-medium">Pattern Type</label>
                  <select 
                    value={settings.type} 
                    onChange={(e) => setSettings(prev => ({ ...prev, type: e.target.value as PatternSettings['type'] }))}
                    className="w-full px-3 py-2 bg-white/20 border border-white/30 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-white/50"
                  >
                    <option value="ichimatsu" className="bg-gray-800">Ichimatsu (市松)</option>
                    <option value="seigaiha" className="bg-gray-800">Seigaiha (青海波)</option>
                    <option value="asanoha" className="bg-gray-800">Asanoha (麻の葉)</option>
                    <option value="shippo" className="bg-gray-800">Shippo (七宝)</option>
                    <option value="yamaji" className="bg-gray-800">Yamaji (山路)</option>
                  </select>
                </div>

                {/* Size */}
                <div className="space-y-2">
                  <label className="text-white font-medium">Size: <span className="text-yellow-300 font-bold">{settings.size}</span></label>
                  <input
                    type="range"
                    value={settings.size}
                    onChange={(e) => setSettings(prev => ({ ...prev, size: parseInt(e.target.value) }))}
                    min={10}
                    max={100}
                    step={1}
                    className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer"
                  />
                </div>

                {/* Density */}
                <div className="space-y-2">
                  <label className="text-white font-medium">Density: <span className="text-yellow-300 font-bold">{settings.density.toFixed(1)}</span></label>
                  <input
                    type="range"
                    value={settings.density}
                    onChange={(e) => setSettings(prev => ({ ...prev, density: parseFloat(e.target.value) }))}
                    min={0.5}
                    max={3.0}
                    step={0.1}
                    className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer"
                  />
                </div>

                {/* Rotation */}
                <div className="space-y-2">
                  <label className="text-white font-medium">Rotation: <span className="text-yellow-300 font-bold">{settings.rotation}°</span></label>
                  <input
                    type="range"
                    value={settings.rotation}
                    onChange={(e) => setSettings(prev => ({ ...prev, rotation: parseInt(e.target.value) }))}
                    min={0}
                    max={360}
                    step={1}
                    className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer"
                  />
                </div>

                {/* Opacity */}
                <div className="space-y-2">
                  <label className="text-white font-medium">Opacity: <span className="text-yellow-300 font-bold">{settings.opacity}%</span></label>
                  <input
                    type="range"
                    value={settings.opacity}
                    onChange={(e) => setSettings(prev => ({ ...prev, opacity: parseInt(e.target.value) }))}
                    min={10}
                    max={100}
                    step={1}
                    className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer"
                  />
                </div>

                {/* Colors */}
                <div className="space-y-3">
                  <label className="text-white font-medium">Colors</label>
                  <div className="grid grid-cols-3 gap-2">
                    <div className="space-y-1">
                      <label className="text-xs text-white/70">Primary</label>
                      <input
                        type="color"
                        value={settings.primaryColor}
                        onChange={(e) => setSettings(prev => ({ ...prev, primaryColor: e.target.value }))}
                        className="w-full h-10 rounded cursor-pointer"
                      />
                    </div>
                    <div className="space-y-1">
                      <label className="text-xs text-white/70">Secondary</label>
                      <input
                        type="color"
                        value={settings.secondaryColor}
                        onChange={(e) => setSettings(prev => ({ ...prev, secondaryColor: e.target.value }))}
                        className="w-full h-10 rounded cursor-pointer"
                      />
                    </div>
                    <div className="space-y-1">
                      <label className="text-xs text-white/70">Accent</label>
                      <input
                        type="color"
                        value={settings.accentColor}
                        onChange={(e) => setSettings(prev => ({ ...prev, accentColor: e.target.value }))}
                        className="w-full h-10 rounded cursor-pointer"
                      />
                    </div>
                  </div>
                </div>

                {/* Color Palettes */}
                <div className="space-y-2">
                  <label className="text-white font-medium">Color Palettes</label>
                  <div className="grid grid-cols-2 gap-2">
                    {COLOR_PALETTES.map((palette) => (
                      <button
                        key={palette.name}
                        onClick={() => applyPalette(palette)}
                        className="flex gap-1 p-2 rounded bg-white/10 hover:bg-white/20 transition-colors"
                        title={palette.name}
                      >
                        {palette.colors.map((color, i) => (
                          <div
                            key={i}
                            className="w-full h-6 rounded"
                            style={{ backgroundColor: color }}
                          />
                        ))}
                      </button>
                    ))}
                  </div>
                </div>

                {/* Action Buttons */}
                <div className="space-y-2">
                  <button
                    onClick={randomizePattern}
                    className="w-full px-4 py-2 bg-gradient-to-r from-orange-500 to-pink-500 hover:from-orange-600 hover:to-pink-600 text-white font-medium rounded-md transition-all transform hover:scale-105 flex items-center justify-center gap-2"
                  >
                    <Shuffle className="w-4 h-4" />
                    Randomize Pattern
                  </button>
                  
                  <div className="flex gap-2">
                    <button
                      onClick={() => exportPattern('png')}
                      className="flex-1 px-4 py-2 bg-white/20 hover:bg-white/30 text-white font-medium rounded-md transition-colors flex items-center justify-center gap-2"
                    >
                      <Download className="w-4 h-4" />
                      PNG
                    </button>
                    <button
                      onClick={() => exportPattern('svg')}
                      className="flex-1 px-4 py-2 bg-white/20 hover:bg-white/30 text-white font-medium rounded-md transition-colors flex items-center justify-center gap-2"
                    >
                      <Download className="w-4 h-4" />
                      SVG
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Pattern Preview */}
          <div className="lg:col-span-2">
            <div className="bg-white/10 backdrop-blur-md border border-white/20 rounded-lg p-6">
              <h2 className="text-xl font-semibold text-white mb-6">Pattern Preview</h2>
              <div className="flex items-center justify-center">
                <div className="bg-white rounded-lg p-4 shadow-2xl">
                  <canvas
                    ref={canvasRef}
                    width={600}
                    height={600}
                    className="max-w-full h-auto"
                    style={{ maxHeight: '60vh' }}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
import React, { useRef, useEffect, useState, useCallback } from 'react'
import { Canvas as FabricCanvas, Point, Rect, Circle, Triangle, FabricObject } from 'fabric'
import type { TEvent } from 'fabric'
import { useAppStore } from '../../hooks/useAppStore'
import { CanvasControls } from './CanvasControls'
import { ExportDialog } from './ExportDialog'
import { PatternLibrary } from './PatternLibrary'

export const Canvas = React.forwardRef<any, {}>((props, ref) => {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const fabricRef = useRef<any>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const [showExportDialog, setShowExportDialog] = useState(false)
  const [showPatternLibrary, setShowPatternLibrary] = useState(true)
  
  const { 
    activeColor, 
    activeLayerId, 
    zoom,
    setZoom 
  } = useAppStore()

  // Initialize Fabric.js canvas
  useEffect(() => {
    if (!canvasRef.current || fabricRef.current) return

    const canvas = new FabricCanvas(canvasRef.current, {
      backgroundColor: '#ffffff',
      selection: true,
      preserveObjectStacking: true
    })

    fabricRef.current = canvas
    
    // Forward ref to parent component
    if (ref) {
      if (typeof ref === 'function') {
        ref(canvas)
      } else {
        ref.current = canvas
      }
    }

    // Set initial size
    const handleResize = () => {
      if (!fabricRef.current || !containerRef.current) return
      
      const { width, height } = containerRef.current.getBoundingClientRect()
      fabricRef.current.setDimensions({ width, height })
      fabricRef.current.renderAll()
    }
    
    handleResize()

    // Event listeners
    canvas.on('mouse:wheel', handleWheel)
    canvas.on('object:added', handleObjectAdded)
    canvas.on('object:modified', handleObjectModified)
    canvas.on('selection:created', handleSelection)
    canvas.on('selection:cleared', handleSelectionCleared)

    return () => {
      canvas.dispose()
      fabricRef.current = null
    }
  }, [])

  // Handle window resize
  useEffect(() => {
    const handleWindowResize = () => {
      if (!fabricRef.current || !containerRef.current) return
      
      const { width, height } = containerRef.current.getBoundingClientRect()
      fabricRef.current.setDimensions({ width, height })
      fabricRef.current.renderAll()
    }

    window.addEventListener('resize', handleWindowResize)
    handleWindowResize()

    return () => window.removeEventListener('resize', handleWindowResize)
  }, [])

  // Update active color for drawing
  useEffect(() => {
    if (!fabricRef.current) return
    
    // Ensure freeDrawingBrush exists before setting properties
    if (fabricRef.current.freeDrawingBrush) {
      fabricRef.current.freeDrawingBrush.color = activeColor
      fabricRef.current.freeDrawingBrush.width = 2
    }
  }, [activeColor])

  // Handle zoom changes
  useEffect(() => {
    if (!fabricRef.current) return
    fabricRef.current.setZoom(zoom)
    fabricRef.current.renderAll()
  }, [zoom])

  // Mouse wheel zoom
  const handleWheel = useCallback((opt: TEvent<WheelEvent>) => {
    const delta = opt.e.deltaY
    let newZoom = zoom * (0.999 ** delta)
    newZoom = Math.max(0.1, Math.min(5, newZoom))
    
    setZoom(newZoom)
    
    if (fabricRef.current) {
      const point = new Point(opt.e.offsetX, opt.e.offsetY)
      fabricRef.current.zoomToPoint(point, newZoom)
    }
    
    opt.e.preventDefault()
    opt.e.stopPropagation()
  }, [zoom, setZoom])

  // Handle object events
  const handleObjectAdded = useCallback((e: any) => {
    // Add object to active layer
    console.log('Object added:', e.target)
  }, [activeLayerId])

  const handleObjectModified = useCallback((e: any) => {
    // Update layer data
    console.log('Object modified:', e.target)
  }, [])

  const handleSelection = useCallback((e: any) => {
    console.log('Selection created:', e.selected)
  }, [])

  const handleSelectionCleared = useCallback(() => {
    console.log('Selection cleared')
  }, [])

  // Drawing tools
  const setDrawingMode = useCallback((mode: 'select' | 'draw' | 'shape' | 'text') => {
    if (!fabricRef.current) return

    switch (mode) {
      case 'select':
        fabricRef.current.isDrawingMode = false
        fabricRef.current.selection = true
        break
      case 'draw':
        fabricRef.current.isDrawingMode = true
        fabricRef.current.selection = false
        break
      case 'shape':
        fabricRef.current.isDrawingMode = false
        // Add shape drawing logic
        break
      case 'text':
        fabricRef.current.isDrawingMode = false
        // Add text tool logic
        break
    }
  }, [])

  // Add shape to canvas
  const addShape = useCallback((type: 'rect' | 'circle' | 'triangle') => {
    if (!fabricRef.current) return

    let shape: FabricObject

    switch (type) {
      case 'rect':
        shape = new Rect({
          left: 100,
          top: 100,
          width: 100,
          height: 100,
          fill: activeColor,
          strokeWidth: 0
        })
        break
      case 'circle':
        shape = new Circle({
          left: 100,
          top: 100,
          radius: 50,
          fill: activeColor,
          strokeWidth: 0
        })
        break
      case 'triangle':
        shape = new Triangle({
          left: 100,
          top: 100,
          width: 100,
          height: 100,
          fill: activeColor,
          strokeWidth: 0
        })
        break
    }

    fabricRef.current.add(shape)
    fabricRef.current.setActiveObject(shape)
    fabricRef.current.renderAll()
  }, [activeColor])

  // Clear canvas
  const clearCanvas = useCallback(() => {
    if (!fabricRef.current) return
    fabricRef.current.clear()
    fabricRef.current.backgroundColor = '#ffffff'
    fabricRef.current.renderAll()
  }, [])

  // Open export dialog
  const openExportDialog = useCallback(() => {
    setShowExportDialog(true)
  }, [])
  
  // Generate test pattern
  const generateTestPattern = useCallback(() => {
    if (!fabricRef.current) return
    
    // Clear canvas
    fabricRef.current.clear()
    fabricRef.current.backgroundColor = '#ffffff'
    
    // Create a simple geometric pattern
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7']
    const size = 40
    const rows = Math.ceil(fabricRef.current.height! / size)
    const cols = Math.ceil(fabricRef.current.width! / size)
    
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const colorIndex = (row + col) % colors.length
        const shape = (row + col) % 3
        
        let element
        if (shape === 0) {
          element = new Circle({
            left: col * size + size/2,
            top: row * size + size/2,
            radius: size/3,
            fill: colors[colorIndex],
            originX: 'center',
            originY: 'center',
            selectable: false
          })
        } else if (shape === 1) {
          element = new Rect({
            left: col * size + size/2,
            top: row * size + size/2,
            width: size * 0.8,
            height: size * 0.8,
            fill: colors[colorIndex],
            originX: 'center',
            originY: 'center',
            selectable: false
          })
        } else {
          element = new Triangle({
            left: col * size + size/2,
            top: row * size + size/2,
            width: size * 0.8,
            height: size * 0.8,
            fill: colors[colorIndex],
            originX: 'center',
            originY: 'center',
            selectable: false
          })
        }
        
        fabricRef.current.add(element)
      }
    }
    
    fabricRef.current.renderAll()
  }, [])


  return (
    <div ref={containerRef} className="relative w-full h-full bg-gray-50 flex" data-testid="main-canvas">
      {/* Canvas container */}
      <div className="flex-1 relative">
        {/* Canvas element */}
        <canvas ref={canvasRef} id="drawing-canvas" data-testid="drawing-canvas" />
        
        {/* Canvas controls */}
        <CanvasControls
          onModeChange={setDrawingMode}
          onAddShape={addShape}
          onClear={clearCanvas}
          onExport={openExportDialog}
          onTogglePatterns={() => setShowPatternLibrary(!showPatternLibrary)}
          showPatternLibrary={showPatternLibrary}
          onGenerateTestPattern={generateTestPattern}
        />
        
        {/* Export dialog */}
        <ExportDialog
          isOpen={showExportDialog}
          onClose={() => setShowExportDialog(false)}
          canvas={fabricRef.current}
        />
      </div>
      
      {/* Pattern library */}
      {showPatternLibrary && (
        <PatternLibrary
          canvas={fabricRef.current}
          onClose={() => setShowPatternLibrary(false)}
        />
      )}
    </div>
  )
})

Canvas.displayName = 'Canvas'
import React, { useRef, useEffect, useState } from 'react'
import * as monaco from 'monaco-editor'
import { Play, Save, Copy, RefreshCw, Loader2 } from 'lucide-react'
import { useAppStore } from '../../hooks/useAppStore'
import { CodeExecutionEngine } from '../../core/execution/CodeExecutionEngine'
import { GraphicsBridge } from '../../core/execution/GraphicsBridge'
import { GraphicsEngine } from '../../graphics/engine/GraphicsEngine'

// TypeScript definitions for the Genshi API
const GENSHI_TYPES = `
declare namespace Genshi {
  interface Canvas {
    width: number
    height: number
    background(color: string): void
    clear(): void
  }
  
  interface Drawing {
    fill(color: string): void
    stroke(color: string): void
    strokeWidth(width: number): void
    noFill(): void
    noStroke(): void
  }
  
  interface Shapes {
    rect(x: number, y: number, width: number, height: number): void
    circle(x: number, y: number, radius: number): void
    ellipse(x: number, y: number, width: number, height: number): void
    line(x1: number, y1: number, x2: number, y2: number): void
    triangle(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void
    polygon(...points: number[]): void
  }
  
  interface Patterns {
    japanese: {
      seigaiha(scale?: number): Pattern
      asanoha(scale?: number): Pattern
      shippo(scale?: number): Pattern
    }
    celtic: {
      knot(complexity?: number): Pattern
      spiral(turns?: number): Pattern
    }
    islamic: {
      geometric(sides?: number): Pattern
      arabesque(complexity?: number): Pattern
    }
  }
  
  interface Pattern {
    apply(): void
    scale(factor: number): Pattern
    rotate(angle: number): Pattern
    translate(x: number, y: number): Pattern
  }
}

declare const canvas: Genshi.Canvas
declare const draw: Genshi.Drawing
declare const shapes: Genshi.Shapes
declare const patterns: Genshi.Patterns
`

const DEFAULT_CODE = `// Welcome to Genshi Studio Code Editor
// Use the Genshi API to create graphics programmatically

// Set up the canvas
canvas.background('#f0f0f0')

// Draw a simple pattern
draw.fill('#3b82f6')
draw.noStroke()

for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 10; j++) {
    const x = i * 60 + 30
    const y = j * 60 + 30
    shapes.circle(x, y, 20)
  }
}

// Apply a Japanese pattern
const pattern = patterns.japanese.seigaiha(2)
pattern.apply()
`

export function CodeEditor() {
  const editorRef = useRef<HTMLDivElement>(null)
  const monacoRef = useRef<monaco.editor.IStandaloneCodeEditor | null>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const graphicsEngineRef = useRef<GraphicsEngine | null>(null)
  const executionEngineRef = useRef<CodeExecutionEngine | null>(null)
  const graphicsBridgeRef = useRef<GraphicsBridge | null>(null)
  
  const [output, setOutput] = useState<string>('')
  const [isRunning, setIsRunning] = useState(false)
  const [executionTime, setExecutionTime] = useState<number | null>(null)

  useEffect(() => {
    if (!editorRef.current || monacoRef.current) return

    // Configure Monaco Editor
    monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
      noSemanticValidation: false,
      noSyntaxValidation: false
    })

    monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
      target: monaco.languages.typescript.ScriptTarget.ES2020,
      allowNonTsExtensions: true
    })

    // Add Genshi type definitions
    monaco.languages.typescript.typescriptDefaults.addExtraLib(
      GENSHI_TYPES,
      'genshi.d.ts'
    )

    // Create editor instance
    const editor = monaco.editor.create(editorRef.current, {
      value: DEFAULT_CODE,
      language: 'typescript',
      theme: 'vs-dark',
      automaticLayout: true,
      minimap: { enabled: false },
      fontSize: 14,
      lineNumbers: 'on',
      scrollBeyondLastLine: false,
      wordWrap: 'on',
      formatOnPaste: true,
      formatOnType: true
    })

    monacoRef.current = editor

    return () => {
      editor.dispose()
      monacoRef.current = null
    }
  }, [])

  // Initialize graphics engine and execution engine
  useEffect(() => {
    if (!canvasRef.current) return

    // Create graphics engine
    const graphicsEngine = new GraphicsEngine({
      canvas: canvasRef.current,
      pixelRatio: window.devicePixelRatio
    })
    graphicsEngineRef.current = graphicsEngine

    // Create graphics bridge
    const graphicsBridge = new GraphicsBridge(graphicsEngine)
    graphicsBridgeRef.current = graphicsBridge

    // Create execution engine
    const executionEngine = new CodeExecutionEngine()
    executionEngineRef.current = executionEngine

    // Connect graphics bridge to execution engine
    executionEngine.connectGraphicsEngine(graphicsBridge)

    return () => {
      executionEngine.destroy()
      graphicsEngine.destroy()
    }
  }, [])

  // Run code
  const runCode = async () => {
    if (!monacoRef.current || !executionEngineRef.current) return
    
    setIsRunning(true)
    setOutput('Transpiling and executing code...')
    setExecutionTime(null)
    
    try {
      const code = monacoRef.current.getValue()
      
      // Execute code through the execution engine
      const result = await executionEngineRef.current.execute(code)
      
      if (result.success) {
        const totalTime = result.performance.transpileTime + result.performance.executionTime
        setExecutionTime(totalTime)
        
        let outputText = 'Code executed successfully!\n'
        outputText += `Transpilation: ${result.performance.transpileTime.toFixed(2)}ms\n`
        outputText += `Execution: ${result.performance.executionTime.toFixed(2)}ms\n`
        
        if (result.logs.length > 0) {
          outputText += '\n--- Console Output ---\n'
          outputText += result.logs.join('\n')
        }
        
        setOutput(outputText)
      } else {
        setOutput(`Error: ${result.error}\n${result.logs.join('\n')}`)
      }
      
    } catch (error) {
      setOutput(`Fatal Error: ${error instanceof Error ? error.message : String(error)}`)
    } finally {
      setIsRunning(false)
    }
  }

  // Save code
  const saveCode = () => {
    if (!monacoRef.current) return
    
    const code = monacoRef.current.getValue()
    const blob = new Blob([code], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    
    const a = document.createElement('a')
    a.href = url
    a.download = 'genshi-code.ts'
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  // Copy code
  const copyCode = async () => {
    if (!monacoRef.current) return
    
    const code = monacoRef.current.getValue()
    await navigator.clipboard.writeText(code)
    setOutput('Code copied to clipboard!')
    setTimeout(() => setOutput(''), 2000)
  }

  // Reset code
  const resetCode = () => {
    if (!monacoRef.current) return
    monacoRef.current.setValue(DEFAULT_CODE)
  }

  return (
    <div className="flex h-full">
      {/* Code editor panel */}
      <div className="flex-1 flex flex-col">
        {/* Editor toolbar */}
        <div className="h-12 border-b border-border bg-card px-4 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <button
              onClick={runCode}
              disabled={isRunning}
              className="flex items-center gap-2 px-4 py-1.5 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors disabled:opacity-50"
            >
              {isRunning ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Play className="h-4 w-4" />
              )}
              <span>{isRunning ? 'Running...' : 'Run'}</span>
            </button>
            
            <button
              onClick={saveCode}
              className="p-2 hover:bg-accent rounded-md transition-colors"
              aria-label="Save code"
            >
              <Save className="h-4 w-4" />
            </button>
            
            <button
              onClick={copyCode}
              className="p-2 hover:bg-accent rounded-md transition-colors"
              aria-label="Copy code"
            >
              <Copy className="h-4 w-4" />
            </button>
            
            <button
              onClick={resetCode}
              className="p-2 hover:bg-accent rounded-md transition-colors"
              aria-label="Reset code"
            >
              <RefreshCw className="h-4 w-4" />
            </button>
          </div>
          
          <div className="text-sm text-muted-foreground">
            TypeScript • Genshi API
          </div>
        </div>
        
        {/* Monaco editor */}
        <div ref={editorRef} className="flex-1" />
        
        {/* Output panel */}
        {output && (
          <div className="h-32 border-t border-border bg-muted p-4 font-mono text-sm overflow-y-auto">
            <pre className="whitespace-pre-wrap">{output}</pre>
          </div>
        )}
      </div>
      
      {/* Preview panel */}
      <div className="w-1/2 border-l border-border bg-gray-50 relative">
        {/* Preview header */}
        <div className="h-12 border-b border-border bg-card px-4 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <span className="text-sm font-medium">Preview</span>
            {executionTime !== null && (
              <span className="text-xs text-muted-foreground">
                Executed in {executionTime.toFixed(2)}ms
              </span>
            )}
          </div>
          <div className="flex items-center gap-1">
            <button
              onClick={() => graphicsBridgeRef.current?.clearExecutionLayer()}
              className="p-1.5 hover:bg-accent rounded-md transition-colors text-xs"
              title="Clear canvas"
            >
              Clear
            </button>
          </div>
        </div>
        
        {/* Canvas container */}
        <div className="relative w-full h-[calc(100%-3rem)]">
          <canvas 
            ref={canvasRef}
            className="absolute inset-0 w-full h-full"
            style={{ imageRendering: 'crisp-edges' }}
          />
          {!executionTime && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
              <div className="text-center text-muted-foreground">
                <p className="text-sm">Run your code to see the result</p>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Plus, 
  Layers, 
  Eye, 
  EyeOff, 
  Minimize2,
  Copy,
  Trash2,
  ArrowUp,
  ArrowDown,
  Settings,
  Blend,
  Palette,
  X
} from 'lucide-react';
import { 
  PatternCombination, 
  CustomPattern, 
  BlendMode,
  Point
} from '../../types/graphics';
import { PatternType } from '../../graphics/patterns/CulturalPatternGenerator';
import { AdvancedPatternGenerator } from '../../graphics/patterns/AdvancedPatternGenerator';
import { PatternStorageService } from '../../services/PatternStorageService';

interface PatternLayer {
  id: string;
  patternId: string;
  name: string;
  pattern: CustomPattern;
  blendMode: BlendMode;
  opacity: number;
  offset: Point;
  scale: number;
  rotation: number;
  visible: boolean;
}

interface PatternCombinerProps {
  onCombinationChange: (combination: PatternCombination) => void;
  width: number;
  height: number;
  className?: string;
}

export function PatternCombiner({ 
  onCombinationChange, 
  width, 
  height, 
  className 
}: PatternCombinerProps) {
  const [layers, setLayers] = useState<PatternLayer[]>([]);
  const [selectedLayer, setSelectedLayer] = useState<string | null>(null);
  const [availablePatterns, setAvailablePatterns] = useState<CustomPattern[]>([]);
  const [compositionMode, setCompositionMode] = useState<'overlay' | 'multiply' | 'screen' | 'difference'>('overlay');
  const [showPatternPicker, setShowPatternPicker] = useState(false);
  const [previewImage, setPreviewImage] = useState<string | null>(null);
  
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const generatorRef = useRef<AdvancedPatternGenerator | null>(null);
  const dragLayer = useRef<string | null>(null);
  const dragStart = useRef<Point>({ x: 0, y: 0 });

  // Initialize pattern generator
  useEffect(() => {
    if (!generatorRef.current) {
      generatorRef.current = new AdvancedPatternGenerator();
    }
    
    return () => {
      if (generatorRef.current) {
        generatorRef.current.destroy();
      }
    };
  }, []);

  // Load available patterns
  useEffect(() => {
    const patterns = PatternStorageService.getAllPatterns();
    setAvailablePatterns(patterns);
  }, []);

  // Update combination when layers change
  useEffect(() => {
    const combination: PatternCombination = {
      id: crypto.randomUUID(),
      patterns: layers.map(layer => ({
        patternId: layer.patternId,
        blendMode: layer.blendMode,
        opacity: layer.opacity,
        offset: layer.offset,
        scale: layer.scale,
        rotation: layer.rotation
      })),
      compositionMode
    };
    
    onCombinationChange(combination);
    renderCombination();
  }, [layers, compositionMode, onCombinationChange]);

  const renderCombination = useCallback(async () => {
    if (!generatorRef.current || !canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    canvas.width = width;
    canvas.height = height;
    ctx.clearRect(0, 0, width, height);
    
    // Set composition mode
    ctx.globalCompositeOperation = compositionMode;
    
    // Render each visible layer
    for (const layer of layers) {
      if (!layer.visible) continue;
      
      try {
        // Generate pattern for this layer
        const patternData = generatorRef.current.generateCustomPattern(
          layer.pattern,
          width,
          height
        );
        
        // Create temporary canvas for this layer
        const tempCanvas = new OffscreenCanvas(width, height);
        const tempCtx = tempCanvas.getContext('2d');
        if (!tempCtx) continue;
        
        tempCtx.putImageData(patternData, 0, 0);
        
        // Apply layer transformations
        ctx.save();
        ctx.globalAlpha = layer.opacity;
        ctx.globalCompositeOperation = layer.blendMode as GlobalCompositeOperation;
        
        // Apply transformations
        ctx.translate(layer.offset.x + width / 2, layer.offset.y + height / 2);
        ctx.rotate(layer.rotation * Math.PI / 180);
        ctx.scale(layer.scale, layer.scale);
        ctx.translate(-width / 2, -height / 2);
        
        // Draw the pattern
        ctx.drawImage(tempCanvas, 0, 0);
        
        ctx.restore();
      } catch (error) {
        console.error('Error rendering layer:', layer.name, error);
      }
    }
    
    // Update preview image
    setPreviewImage(canvas.toDataURL());
  }, [layers, compositionMode, width, height]);

  const addLayer = useCallback((pattern: CustomPattern) => {
    const newLayer: PatternLayer = {
      id: crypto.randomUUID(),
      patternId: pattern.id,
      name: pattern.name,
      pattern,
      blendMode: BlendMode.Normal,
      opacity: 1,
      offset: { x: 0, y: 0 },
      scale: 1,
      rotation: 0,
      visible: true
    };
    
    setLayers(prev => [...prev, newLayer]);
    setSelectedLayer(newLayer.id);
    setShowPatternPicker(false);
  }, []);

  const removeLayer = useCallback((layerId: string) => {
    setLayers(prev => prev.filter(layer => layer.id !== layerId));
    setSelectedLayer(null);
  }, []);

  const updateLayer = useCallback((layerId: string, updates: Partial<PatternLayer>) => {
    setLayers(prev => 
      prev.map(layer => 
        layer.id === layerId 
          ? { ...layer, ...updates }
          : layer
      )
    );
  }, []);

  const duplicateLayer = useCallback((layerId: string) => {
    const layer = layers.find(l => l.id === layerId);
    if (!layer) return;
    
    const duplicatedLayer: PatternLayer = {
      ...layer,
      id: crypto.randomUUID(),
      name: `${layer.name} Copy`,
      offset: { x: layer.offset.x + 10, y: layer.offset.y + 10 }
    };
    
    setLayers(prev => [...prev, duplicatedLayer]);
  }, [layers]);

  const moveLayer = useCallback((layerId: string, direction: 'up' | 'down') => {
    setLayers(prev => {
      const index = prev.findIndex(layer => layer.id === layerId);
      if (index === -1) return prev;
      
      const newIndex = direction === 'up' ? index - 1 : index + 1;
      if (newIndex < 0 || newIndex >= prev.length) return prev;
      
      const newLayers = [...prev];
      [newLayers[index], newLayers[newIndex]] = [newLayers[newIndex], newLayers[index]];
      return newLayers;
    });
  }, []);

  const handleLayerDragStart = useCallback((layerId: string, e: React.MouseEvent) => {
    dragLayer.current = layerId;
    dragStart.current = { x: e.clientX, y: e.clientY };
    
    const handleMouseMove = (e: MouseEvent) => {
      if (!dragLayer.current) return;
      
      const deltaX = e.clientX - dragStart.current.x;
      const deltaY = e.clientY - dragStart.current.y;
      
      updateLayer(dragLayer.current, {
        offset: { x: deltaX, y: deltaY }
      });
    };
    
    const handleMouseUp = () => {
      dragLayer.current = null;
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [updateLayer]);

  const selectedLayerData = selectedLayer ? layers.find(l => l.id === selectedLayer) : null;

  return (
    <div className={`flex gap-4 ${className}`}>
      {/* Layers Panel */}
      <div className="w-80 bg-card border border-border rounded-lg p-4">
        <div className="flex items-center justify-between mb-4">
          <h3 className="font-semibold flex items-center gap-2">
            <Layers className="h-4 w-4" />
            Layers
          </h3>
          <button
            onClick={() => setShowPatternPicker(true)}
            className="p-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors"
            title="Add Layer"
          >
            <Plus className="h-4 w-4" />
          </button>
        </div>

        {/* Composition Mode */}
        <div className="mb-4">
          <label className="text-sm font-medium mb-2 block">Composition Mode</label>
          <select
            value={compositionMode}
            onChange={(e) => setCompositionMode(e.target.value as any)}
            className="w-full p-2 rounded border border-border bg-background"
          >
            <option value="overlay">Overlay</option>
            <option value="multiply">Multiply</option>
            <option value="screen">Screen</option>
            <option value="difference">Difference</option>
          </select>
        </div>

        {/* Layer List */}
        <div className="space-y-2 max-h-96 overflow-y-auto">
          {layers.map((layer, index) => (
            <motion.div
              key={layer.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              className={`p-3 border rounded-lg cursor-pointer transition-colors ${
                selectedLayer === layer.id
                  ? 'border-primary bg-primary/10'
                  : 'border-border hover:border-primary/50'
              }`}
              onClick={() => setSelectedLayer(layer.id)}
            >
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      updateLayer(layer.id, { visible: !layer.visible });
                    }}
                    className="p-1 hover:bg-accent rounded"
                  >
                    {layer.visible ? (
                      <Eye className="h-3 w-3" />
                    ) : (
                      <EyeOff className="h-3 w-3" />
                    )}
                  </button>
                  <span className="text-sm font-medium">{layer.name}</span>
                </div>
                
                <div className="flex items-center gap-1">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      moveLayer(layer.id, 'up');
                    }}
                    disabled={index === 0}
                    className="p-1 hover:bg-accent rounded disabled:opacity-50"
                  >
                    <ArrowUp className="h-3 w-3" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      moveLayer(layer.id, 'down');
                    }}
                    disabled={index === layers.length - 1}
                    className="p-1 hover:bg-accent rounded disabled:opacity-50"
                  >
                    <ArrowDown className="h-3 w-3" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      duplicateLayer(layer.id);
                    }}
                    className="p-1 hover:bg-accent rounded"
                  >
                    <Copy className="h-3 w-3" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      removeLayer(layer.id);
                    }}
                    className="p-1 hover:bg-accent rounded text-red-500"
                  >
                    <Trash2 className="h-3 w-3" />
                  </button>
                </div>
              </div>
              
              <div className="mt-2 text-xs text-muted-foreground">
                {layer.blendMode} • {Math.round(layer.opacity * 100)}%
              </div>
            </motion.div>
          ))}
        </div>
      </div>

      {/* Properties Panel */}
      <div className="w-80 bg-card border border-border rounded-lg p-4">
        <h3 className="font-semibold mb-4 flex items-center gap-2">
          <Settings className="h-4 w-4" />
          Properties
        </h3>
        
        {selectedLayerData ? (
          <div className="space-y-4">
            <div>
              <label className="text-sm font-medium mb-2 block">Blend Mode</label>
              <select
                value={selectedLayerData.blendMode}
                onChange={(e) => updateLayer(selectedLayerData.id, { blendMode: e.target.value as BlendMode })}
                className="w-full p-2 rounded border border-border bg-background"
              >
                {Object.values(BlendMode).map(mode => (
                  <option key={mode} value={mode}>
                    {mode.charAt(0).toUpperCase() + mode.slice(1)}
                  </option>
                ))}
              </select>
            </div>
            
            <div>
              <label className="text-sm font-medium mb-2 block">
                Opacity ({Math.round(selectedLayerData.opacity * 100)}%)
              </label>
              <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                value={selectedLayerData.opacity}
                onChange={(e) => updateLayer(selectedLayerData.id, { opacity: parseFloat(e.target.value) })}
                className="w-full"
              />
            </div>
            
            <div>
              <label className="text-sm font-medium mb-2 block">
                Scale ({selectedLayerData.scale.toFixed(2)})
              </label>
              <input
                type="range"
                min="0.1"
                max="3"
                step="0.1"
                value={selectedLayerData.scale}
                onChange={(e) => updateLayer(selectedLayerData.id, { scale: parseFloat(e.target.value) })}
                className="w-full"
              />
            </div>
            
            <div>
              <label className="text-sm font-medium mb-2 block">
                Rotation ({selectedLayerData.rotation}°)
              </label>
              <input
                type="range"
                min="0"
                max="360"
                step="1"
                value={selectedLayerData.rotation}
                onChange={(e) => updateLayer(selectedLayerData.id, { rotation: parseInt(e.target.value) })}
                className="w-full"
              />
            </div>
            
            <div>
              <label className="text-sm font-medium mb-2 block">Position</label>
              <div className="grid grid-cols-2 gap-2">
                <div>
                  <label className="text-xs text-muted-foreground">X</label>
                  <input
                    type="number"
                    value={selectedLayerData.offset.x}
                    onChange={(e) => updateLayer(selectedLayerData.id, { 
                      offset: { ...selectedLayerData.offset, x: parseInt(e.target.value) || 0 }
                    })}
                    className="w-full p-1 rounded border border-border bg-background"
                  />
                </div>
                <div>
                  <label className="text-xs text-muted-foreground">Y</label>
                  <input
                    type="number"
                    value={selectedLayerData.offset.y}
                    onChange={(e) => updateLayer(selectedLayerData.id, { 
                      offset: { ...selectedLayerData.offset, y: parseInt(e.target.value) || 0 }
                    })}
                    className="w-full p-1 rounded border border-border bg-background"
                  />
                </div>
              </div>
            </div>
          </div>
        ) : (
          <div className="text-center text-muted-foreground">
            <Layers className="h-12 w-12 mx-auto mb-3 opacity-50" />
            <p>Select a layer to edit properties</p>
          </div>
        )}
      </div>

      {/* Preview Canvas */}
      <div className="flex-1 bg-card border border-border rounded-lg p-4">
        <h3 className="font-semibold mb-4">Preview</h3>
        <div className="bg-gray-100 rounded-lg overflow-hidden flex items-center justify-center" style={{ height: '400px' }}>
          <canvas
            ref={canvasRef}
            width={width}
            height={height}
            className="max-w-full max-h-full object-contain"
          />
        </div>
      </div>

      {/* Pattern Picker Modal */}
      <AnimatePresence>
        {showPatternPicker && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={(e) => {
              if (e.target === e.currentTarget) setShowPatternPicker(false);
            }}
          >
            <motion.div
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.9, opacity: 0 }}
              className="bg-card rounded-xl shadow-2xl max-w-2xl w-full max-h-[70vh] overflow-y-auto p-6"
            >
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-semibold">Select Pattern</h3>
                <button
                  onClick={() => setShowPatternPicker(false)}
                  className="p-2 hover:bg-accent rounded-md transition-colors"
                >
                  <X className="h-4 w-4" />
                </button>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                {availablePatterns.map(pattern => (
                  <div
                    key={pattern.id}
                    onClick={() => addLayer(pattern)}
                    className="p-4 border border-border rounded-lg cursor-pointer hover:border-primary transition-colors"
                  >
                    <h4 className="font-medium">{pattern.name}</h4>
                    <p className="text-sm text-muted-foreground">{pattern.description}</p>
                    <div className="mt-2 text-xs text-muted-foreground">
                      {pattern.tags.join(', ')}
                    </div>
                  </div>
                ))}
              </div>
              
              {availablePatterns.length === 0 && (
                <div className="text-center py-8 text-muted-foreground">
                  <Palette className="h-12 w-12 mx-auto mb-3 opacity-50" />
                  <p>No patterns available. Create some patterns first!</p>
                </div>
              )}
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
import React, { useState } from 'react'
import { 
  X,
  Bookmark,
  Star,
  Clock,
  Trash2,
  Download,
  Plus
} from 'lucide-react'
import { motion } from 'framer-motion'
import { useAppStore } from '../../hooks/useAppStore'

interface BookmarkDialogProps {
  isOpen: boolean
  onClose: () => void
}

export function BookmarkDialog({ isOpen, onClose }: BookmarkDialogProps) {
  const { 
    bookmarks, 
    loadBookmark, 
    deleteBookmark, 
    saveBookmark,
    currentProject 
  } = useAppStore()
  
  const [showSaveForm, setShowSaveForm] = useState(false)
  const [bookmarkName, setBookmarkName] = useState('')

  const handleLoadBookmark = (bookmarkId: string) => {
    loadBookmark(bookmarkId)
    onClose()
  }

  const handleDeleteBookmark = (bookmarkId: string, e: React.MouseEvent) => {
    e.stopPropagation()
    if (confirm('Are you sure you want to delete this bookmark?')) {
      deleteBookmark(bookmarkId)
    }
  }

  const handleSaveBookmark = () => {
    if (!currentProject || !bookmarkName.trim()) return
    
    const newBookmark = {
      id: Date.now().toString(),
      name: bookmarkName.trim(),
      projectData: currentProject.data,
      timestamp: new Date()
    }
    
    saveBookmark(newBookmark)
    setBookmarkName('')
    setShowSaveForm(false)
  }

  const handleExportBookmark = (bookmark: any, e: React.MouseEvent) => {
    e.stopPropagation()
    const dataStr = JSON.stringify(bookmark, null, 2)
    const dataBlob = new Blob([dataStr], { type: 'application/json' })
    const url = URL.createObjectURL(dataBlob)
    
    const a = document.createElement('a')
    a.href = url
    a.download = `${bookmark.name.toLowerCase().replace(/\s+/g, '-')}-bookmark.json`
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  const formatDate = (date: Date) => {
    return new Intl.DateTimeFormat('en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }).format(new Date(date))
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="bg-card rounded-lg shadow-xl border border-border w-full max-w-3xl max-h-[80vh] overflow-hidden"
      >
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-border">
          <div>
            <h2 className="text-xl font-semibold">Bookmarks</h2>
            <p className="text-sm text-muted-foreground mt-1">
              Save and load your favorite pattern states
            </p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-accent rounded-md transition-colors"
          >
            <X className="h-5 w-5" />
          </button>
        </div>

        {/* Save New Bookmark Form */}
        {showSaveForm && (
          <div className="p-6 border-b border-border bg-accent/10">
            <div className="flex items-center gap-3">
              <input
                type="text"
                value={bookmarkName}
                onChange={(e) => setBookmarkName(e.target.value)}
                placeholder="Enter bookmark name..."
                className="flex-1 p-2 border border-border rounded-md bg-background"
                autoFocus
                onKeyDown={(e) => {
                  if (e.key === 'Enter') handleSaveBookmark()
                  if (e.key === 'Escape') setShowSaveForm(false)
                }}
              />
              <button
                onClick={handleSaveBookmark}
                disabled={!bookmarkName.trim() || !currentProject}
                className="px-3 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors disabled:opacity-50"
              >
                Save
              </button>
              <button
                onClick={() => setShowSaveForm(false)}
                className="px-3 py-2 border border-border rounded-md hover:bg-accent transition-colors"
              >
                Cancel
              </button>
            </div>
          </div>
        )}

        {/* Content */}
        <div className="p-6 overflow-y-auto max-h-[50vh]">
          {bookmarks.length === 0 ? (
            <div className="text-center py-12">
              <Bookmark className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
              <h3 className="text-lg font-medium mb-2">No Bookmarks Saved</h3>
              <p className="text-muted-foreground mb-4">
                Save your current pattern state to quickly return to it later.
              </p>
              <button
                onClick={() => setShowSaveForm(true)}
                disabled={!currentProject}
                className="flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors disabled:opacity-50 mx-auto"
              >
                <Plus className="h-4 w-4" />
                Save Current State
              </button>
            </div>
          ) : (
            <div className="space-y-3">
              {bookmarks.map((bookmark) => (
                <motion.div
                  key={bookmark.id}
                  whileHover={{ scale: 1.01 }}
                  className="bg-accent/20 rounded-lg border border-border p-4 cursor-pointer hover:bg-accent/30 transition-colors group"
                  onClick={() => handleLoadBookmark(bookmark.id)}
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <div className="p-2 bg-primary/10 rounded">
                        <Star className="h-4 w-4 text-primary" />
                      </div>
                      <div>
                        <h3 className="font-medium">{bookmark.name}</h3>
                        <div className="flex items-center gap-1 text-sm text-muted-foreground">
                          <Clock className="h-3 w-3" />
                          {formatDate(bookmark.timestamp)}
                        </div>
                      </div>
                    </div>
                    
                    <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                      <button
                        onClick={(e) => handleExportBookmark(bookmark, e)}
                        className="p-1.5 hover:bg-accent rounded transition-colors"
                        title="Export bookmark"
                      >
                        <Download className="h-4 w-4" />
                      </button>
                      <button
                        onClick={(e) => handleDeleteBookmark(bookmark.id, e)}
                        className="p-1.5 hover:bg-destructive/20 text-destructive rounded transition-colors"
                        title="Delete bookmark"
                      >
                        <Trash2 className="h-4 w-4" />
                      </button>
                    </div>
                  </div>
                </motion.div>
              ))}
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="flex items-center justify-between p-6 border-t border-border">
          <div className="text-sm text-muted-foreground">
            {bookmarks.length} bookmark{bookmarks.length !== 1 ? 's' : ''} saved
          </div>
          <div className="flex gap-2">
            {!showSaveForm && bookmarks.length > 0 && (
              <button
                onClick={() => setShowSaveForm(true)}
                disabled={!currentProject}
                className="flex items-center gap-2 px-3 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors disabled:opacity-50"
              >
                <Plus className="h-4 w-4" />
                Save Current
              </button>
            )}
            <button
              onClick={onClose}
              className="px-4 py-2 border border-border rounded-md hover:bg-accent transition-colors"
            >
              Close
            </button>
          </div>
        </div>
      </motion.div>
    </div>
  )
}
/**
 * Device Calibration Component
 * Allows users to calibrate their pressure-sensitive devices
 */

import React, { useState, useEffect } from 'react';
import { inputDeviceManager, PressureCurve } from '../input/InputDeviceManager';

interface DeviceCalibrationProps {
  onClose: () => void;
}

export const DeviceCalibration: React.FC<DeviceCalibrationProps> = ({ onClose }) => {
  const [selectedCurve, setSelectedCurve] = useState<string>('default');
  const [availableCurves, setAvailableCurves] = useState<string[]>([]);
  const [customCurve, setCustomCurve] = useState<PressureCurve>({
    name: 'custom',
    controlPoints: [
      { x: 0, y: 0 },
      { x: 0.25, y: 0.25 },
      { x: 0.5, y: 0.5 },
      { x: 0.75, y: 0.75 },
      { x: 1, y: 1 }
    ],
    interpolation: 'cubic'
  });
  const [testPressure, setTestPressure] = useState<number>(0);
  const [isTestingPressure, setIsTestingPressure] = useState(false);

  useEffect(() => {
    const curves = inputDeviceManager.getAvailableCurves();
    setAvailableCurves(curves);
    
    const activeCurve = inputDeviceManager.getActiveCurve();
    setSelectedCurve(activeCurve.name.toLowerCase());
  }, []);

  const handleCurveChange = (curveName: string) => {
    setSelectedCurve(curveName);
    inputDeviceManager.setPressureCurve(curveName);
  };

  const handleCustomPointChange = (index: number, value: number, axis: 'x' | 'y') => {
    const newPoints = [...customCurve.controlPoints];
    newPoints[index] = { ...newPoints[index], [axis]: value };
    
    // Sort points by x value
    if (axis === 'x') {
      newPoints.sort((a, b) => a.x - b.x);
    }
    
    setCustomCurve({ ...customCurve, controlPoints: newPoints });
  };

  const applyCustomCurve = () => {
    inputDeviceManager.addCustomPressureCurve(customCurve);
    inputDeviceManager.setPressureCurve('custom');
    setSelectedCurve('custom');
  };

  const renderCurvePreview = () => {
    const width = 200;
    const height = 200;
    const points = selectedCurve === 'custom' 
      ? customCurve.controlPoints 
      : inputDeviceManager.getActiveCurve().controlPoints;

    return (
      <svg width={width} height={height} style={{ 
        background: 'rgba(255, 255, 255, 0.05)', 
        borderRadius: '4px',
        border: '1px solid rgba(255, 255, 255, 0.1)'
      }}>
        {/* Grid */}
        {[0, 0.25, 0.5, 0.75, 1].map(v => (
          <g key={v}>
            <line
              x1={0}
              y1={height - v * height}
              x2={width}
              y2={height - v * height}
              stroke="rgba(255, 255, 255, 0.1)"
              strokeWidth="1"
            />
            <line
              x1={v * width}
              y1={0}
              x2={v * width}
              y2={height}
              stroke="rgba(255, 255, 255, 0.1)"
              strokeWidth="1"
            />
          </g>
        ))}

        {/* Diagonal reference line */}
        <line
          x1={0}
          y1={height}
          x2={width}
          y2={0}
          stroke="rgba(255, 255, 255, 0.2)"
          strokeWidth="1"
          strokeDasharray="5,5"
        />

        {/* Curve */}
        <polyline
          points={points.map(p => `${p.x * width},${height - p.y * height}`).join(' ')}
          fill="none"
          stroke="#4CAF50"
          strokeWidth="2"
        />

        {/* Control points */}
        {selectedCurve === 'custom' && points.map((point, index) => (
          <circle
            key={index}
            cx={point.x * width}
            cy={height - point.y * height}
            r="4"
            fill="#4CAF50"
            stroke="white"
            strokeWidth="1"
            style={{ cursor: 'pointer' }}
          />
        ))}

        {/* Test pressure indicator */}
        {isTestingPressure && (
          <>
            <line
              x1={testPressure * width}
              y1={0}
              x2={testPressure * width}
              y2={height}
              stroke="#FF5722"
              strokeWidth="2"
            />
            <circle
              cx={testPressure * width}
              cy={height - (testPressure * height)}
              r="6"
              fill="#FF5722"
              stroke="white"
              strokeWidth="2"
            />
          </>
        )}
      </svg>
    );
  };

  return (
    <div style={{
      position: 'fixed',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      width: '600px',
      maxHeight: '80vh',
      background: 'rgba(30, 30, 30, 0.95)',
      color: 'white',
      padding: '20px',
      borderRadius: '12px',
      boxShadow: '0 8px 32px rgba(0, 0, 0, 0.5)',
      backdropFilter: 'blur(10px)',
      overflow: 'auto'
    }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
        <h2 style={{ margin: 0 }}>Device Calibration</h2>
        <button
          onClick={onClose}
          style={{
            background: 'transparent',
            border: 'none',
            color: 'white',
            fontSize: '24px',
            cursor: 'pointer'
          }}
        >
          ×
        </button>
      </div>

      <div style={{ display: 'flex', gap: '20px' }}>
        {/* Left side - Curve selection and preview */}
        <div style={{ flex: 1 }}>
          <h3>Pressure Curve</h3>
          
          {/* Preset curves */}
          <div style={{ marginBottom: '15px' }}>
            <label>Preset Curves:</label>
            <select
              value={selectedCurve}
              onChange={(e) => handleCurveChange(e.target.value)}
              style={{
                width: '100%',
                padding: '8px',
                marginTop: '5px',
                background: 'rgba(255, 255, 255, 0.1)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
                borderRadius: '4px',
                color: 'white'
              }}
            >
              {availableCurves.map(curve => (
                <option key={curve} value={curve}>
                  {curve.charAt(0).toUpperCase() + curve.slice(1)}
                </option>
              ))}
            </select>
          </div>

          {/* Curve preview */}
          <div style={{ marginBottom: '15px' }}>
            {renderCurvePreview()}
          </div>

          {/* Test area */}
          <div>
            <h4>Test Pressure</h4>
            <div
              style={{
                width: '100%',
                height: '60px',
                background: 'rgba(255, 255, 255, 0.1)',
                borderRadius: '4px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                cursor: 'crosshair',
                userSelect: 'none'
              }}
              onPointerDown={(e) => {
                setIsTestingPressure(true);
                setTestPressure(e.pressure);
              }}
              onPointerMove={(e) => {
                if (isTestingPressure) {
                  setTestPressure(e.pressure);
                }
              }}
              onPointerUp={() => {
                setIsTestingPressure(false);
              }}
              onPointerLeave={() => {
                setIsTestingPressure(false);
              }}
            >
              {isTestingPressure ? (
                <span>Pressure: {(testPressure * 100).toFixed(1)}%</span>
              ) : (
                <span>Press here to test pressure</span>
              )}
            </div>
          </div>
        </div>

        {/* Right side - Custom curve editor */}
        <div style={{ flex: 1 }}>
          <h3>Custom Curve Editor</h3>
          
          <div style={{ marginBottom: '15px' }}>
            <label>Control Points:</label>
            {customCurve.controlPoints.map((point, index) => (
              <div key={index} style={{ 
                display: 'flex', 
                gap: '10px', 
                marginTop: '10px',
                alignItems: 'center'
              }}>
                <span style={{ width: '30px' }}>P{index + 1}:</span>
                <div style={{ flex: 1 }}>
                  <label style={{ fontSize: '11px' }}>X:</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.01"
                    value={point.x}
                    onChange={(e) => handleCustomPointChange(index, parseFloat(e.target.value), 'x')}
                    disabled={index === 0 || index === customCurve.controlPoints.length - 1}
                    style={{ width: '100%' }}
                  />
                </div>
                <div style={{ flex: 1 }}>
                  <label style={{ fontSize: '11px' }}>Y:</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.01"
                    value={point.y}
                    onChange={(e) => handleCustomPointChange(index, parseFloat(e.target.value), 'y')}
                    style={{ width: '100%' }}
                  />
                </div>
                <span style={{ fontSize: '11px', minWidth: '80px' }}>
                  ({point.x.toFixed(2)}, {point.y.toFixed(2)})
                </span>
              </div>
            ))}
          </div>

          <button
            onClick={applyCustomCurve}
            style={{
              width: '100%',
              padding: '10px',
              background: '#4CAF50',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold'
            }}
          >
            Apply Custom Curve
          </button>

          {/* Device-specific settings */}
          <div style={{ marginTop: '20px' }}>
            <h4>Device Settings</h4>
            <div style={{ fontSize: '12px', color: 'rgba(255, 255, 255, 0.7)' }}>
              <p>Tips for optimal pressure sensitivity:</p>
              <ul style={{ paddingLeft: '20px' }}>
                <li>Wacom: Use driver settings for initial calibration</li>
                <li>Apple Pencil: Adjust in iPad settings first</li>
                <li>Surface Pen: Configure in Windows Ink settings</li>
                <li>Huion: Install latest drivers for best support</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
import React, { useLayoutEffect } from 'react'

interface ThemeProviderProps {
  theme: 'light' | 'dark'
  children: React.ReactNode
}

export function ThemeProvider({ theme, children }: ThemeProviderProps) {
  // Use useLayoutEffect to apply theme before paint to avoid flash
  useLayoutEffect(() => {
    const root = document.documentElement
    
    if (theme === 'dark') {
      root.classList.add('dark')
    } else {
      root.classList.remove('dark')
    }
  }, [theme])

  return <>{children}</>
}
/**
 * Enhanced Canvas Component with Pressure-Sensitive Input Support
 */

import React, { useRef, useEffect, useState } from 'react';
import { GraphicsEngine } from '../graphics/engine/GraphicsEngine';
import { Color, BrushSettings } from '../types/graphics';
import { PatternType } from '../graphics/patterns/CulturalPatternGenerator';
import { PressureVisualization } from './PressureVisualization';
import { DeviceCalibration } from './DeviceCalibration';
import { inputDeviceManager, PressureData } from '../input/InputDeviceManager';

interface EnhancedCanvasProps {
  width?: number;
  height?: number;
  onEngineReady?: (engine: GraphicsEngine) => void;
}

export const EnhancedCanvas: React.FC<EnhancedCanvasProps> = ({ 
  width = window.innerWidth - 300, 
  height = window.innerHeight - 200,
  onEngineReady 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const engineRef = useRef<GraphicsEngine | null>(null);
  const [isReady, setIsReady] = useState(false);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentPressure, setCurrentPressure] = useState<PressureData | undefined>();
  const [showPressureViz, setShowPressureViz] = useState(true);
  const [showCalibration, setShowCalibration] = useState(false);

  useEffect(() => {
    if (!canvasRef.current) return;

    // Initialize graphics engine
    const engine = new GraphicsEngine({
      canvas: canvasRef.current,
      width,
      height
    });

    engineRef.current = engine;
    setIsReady(true);

    if (onEngineReady) {
      onEngineReady(engine);
    }

    // Set up pressure tracking
    const handlePressureUpdate = (event: any) => {
      if (event.detail) {
        setIsDrawing(event.detail.isDrawing);
        setCurrentPressure(event.detail.pressure);
      }
    };

    window.addEventListener('pressureUpdate', handlePressureUpdate);

    return () => {
      window.removeEventListener('pressureUpdate', handlePressureUpdate);
      engine.destroy();
    };
  }, [width, height, onEngineReady]);

  return (
    <div className="enhanced-canvas-container" style={{ position: 'relative', width, height }}>
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        style={{
          display: 'block',
          border: '1px solid #333',
          cursor: 'crosshair',
          touchAction: 'none',
          background: '#f8f8f8'
        }}
      />
      
      {/* Pressure Visualization */}
      {showPressureViz && (
        <PressureVisualization 
          isDrawing={isDrawing} 
          currentPressure={currentPressure} 
        />
      )}

      {/* Device Calibration Modal */}
      {showCalibration && (
        <DeviceCalibration onClose={() => setShowCalibration(false)} />
      )}

      {/* Quick Controls */}
      <div style={{
        position: 'absolute',
        top: 10,
        right: 10,
        display: 'flex',
        gap: '10px'
      }}>
        <button
          onClick={() => setShowPressureViz(!showPressureViz)}
          style={{
            padding: '8px 12px',
            background: showPressureViz ? '#4CAF50' : 'rgba(0, 0, 0, 0.5)',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '12px'
          }}
        >
          Pressure Info
        </button>
        <button
          onClick={() => setShowCalibration(true)}
          style={{
            padding: '8px 12px',
            background: 'rgba(0, 0, 0, 0.5)',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '12px'
          }}
        >
          Calibrate Device
        </button>
      </div>
    </div>
  );
};

// Enhanced Toolbar with pressure-sensitive brush controls
interface EnhancedToolbarProps {
  engine: GraphicsEngine | null;
}

export const EnhancedToolbar: React.FC<EnhancedToolbarProps> = ({ engine }) => {
  const [currentColor, setCurrentColor] = useState<Color>({ r: 0, g: 0, b: 0, a: 1 });
  const [brushSettings, setBrushSettings] = useState<any>({
    size: 20,
    hardness: 0.8,
    opacity: 1.0,
    flow: 1.0,
    smoothing: 0.5,
    minSize: 1,
    maxSize: 100,
    dynamics: {
      sizePressure: 1.0,
      opacityPressure: 0.7,
      sizeVelocity: 0,
      opacityVelocity: 0,
      sizeTilt: 0,
      opacityTilt: 0
    }
  });
  const [selectedPreset, setSelectedPreset] = useState<string>('');

  const handleColorChange = (color: Color) => {
    setCurrentColor(color);
    engine?.setColor(color);
  };

  const handleBrushSettingChange = (setting: string, value: any) => {
    const newSettings = { ...brushSettings };
    
    // Handle nested settings
    if (setting.includes('.')) {
      const [parent, child] = setting.split('.');
      newSettings[parent] = { ...newSettings[parent], [child]: value };
    } else {
      newSettings[setting] = value;
    }
    
    setBrushSettings(newSettings);
    engine?.updateBrushSettings(newSettings);
  };

  const handlePresetChange = (preset: string) => {
    setSelectedPreset(preset);
    engine?.setBrushPreset(preset);
    
    // Update local settings to reflect preset
    if (engine) {
      const settings = engine.getBrushSettings();
      setBrushSettings(settings);
    }
  };

  const brushPresets = [
    { id: 'pencil', name: 'Pencil', icon: '✏️' },
    { id: 'marker', name: 'Marker', icon: '🖍️' },
    { id: 'watercolor', name: 'Watercolor', icon: '🎨' },
    { id: 'oil', name: 'Oil Paint', icon: '🖌️' },
    { id: 'airbrush', name: 'Airbrush', icon: '💨' }
  ];

  const tools = [
    { id: 'brush', name: 'Brush', icon: '🖌️', action: () => engine?.selectBrushTool() },
    { id: 'eraser', name: 'Eraser', icon: '🧹', action: () => engine?.selectEraserTool() },
    { id: 'pattern', name: 'Pattern', icon: '🔲', action: () => engine?.selectPatternTool() }
  ];

  return (
    <div className="enhanced-toolbar" style={{
      display: 'flex',
      flexDirection: 'column',
      gap: '15px',
      padding: '15px',
      background: '#2a2a2a',
      color: 'white',
      borderBottom: '1px solid #444'
    }}>
      {/* Top row - Tools and presets */}
      <div style={{ display: 'flex', gap: '20px', alignItems: 'center' }}>
        {/* Tool buttons */}
        <div className="tool-buttons" style={{ display: 'flex', gap: '5px' }}>
          {tools.map(tool => (
            <button
              key={tool.id}
              onClick={tool.action}
              title={tool.name}
              style={{
                width: '40px',
                height: '40px',
                fontSize: '20px',
                border: '1px solid #555',
                background: '#3a3a3a',
                color: 'white',
                cursor: 'pointer',
                borderRadius: '4px',
                transition: 'all 0.2s'
              }}
              onMouseEnter={(e) => e.currentTarget.style.background = '#4a4a4a'}
              onMouseLeave={(e) => e.currentTarget.style.background = '#3a3a3a'}
            >
              {tool.icon}
            </button>
          ))}
        </div>

        {/* Brush presets */}
        <div className="brush-presets" style={{ display: 'flex', gap: '5px' }}>
          <span style={{ marginRight: '10px', alignSelf: 'center' }}>Presets:</span>
          {brushPresets.map(preset => (
            <button
              key={preset.id}
              onClick={() => handlePresetChange(preset.id)}
              title={preset.name}
              style={{
                padding: '8px 12px',
                fontSize: '14px',
                border: selectedPreset === preset.id ? '2px solid #4CAF50' : '1px solid #555',
                background: selectedPreset === preset.id ? '#3a3a3a' : '#2a2a2a',
                color: 'white',
                cursor: 'pointer',
                borderRadius: '4px',
                display: 'flex',
                alignItems: 'center',
                gap: '5px'
              }}
            >
              {preset.icon} {preset.name}
            </button>
          ))}
        </div>

        {/* Color picker */}
        <div className="color-picker" style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <label>Color:</label>
          <input
            type="color"
            value={`#${Math.round(currentColor.r * 255).toString(16).padStart(2, '0')}${Math.round(currentColor.g * 255).toString(16).padStart(2, '0')}${Math.round(currentColor.b * 255).toString(16).padStart(2, '0')}`}
            onChange={(e) => {
              const hex = e.target.value;
              const r = parseInt(hex.substr(1, 2), 16) / 255;
              const g = parseInt(hex.substr(3, 2), 16) / 255;
              const b = parseInt(hex.substr(5, 2), 16) / 255;
              handleColorChange({ r, g, b, a: currentColor.a });
            }}
            style={{
              width: '50px',
              height: '30px',
              border: '1px solid #555',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          />
        </div>
      </div>

      {/* Bottom row - Brush settings */}
      <div style={{ display: 'flex', gap: '20px', fontSize: '12px' }}>
        {/* Basic settings */}
        <div style={{ display: 'flex', gap: '15px' }}>
          <div>
            <label>Size: </label>
            <input
              type="range"
              min={brushSettings.minSize || 1}
              max={brushSettings.maxSize || 100}
              value={brushSettings.size}
              onChange={(e) => handleBrushSettingChange('size', Number(e.target.value))}
              style={{ width: '100px' }}
            />
            <span style={{ marginLeft: '5px' }}>{brushSettings.size}px</span>
          </div>

          <div>
            <label>Opacity: </label>
            <input
              type="range"
              min="0"
              max="100"
              value={brushSettings.opacity * 100}
              onChange={(e) => handleBrushSettingChange('opacity', Number(e.target.value) / 100)}
              style={{ width: '100px' }}
            />
            <span style={{ marginLeft: '5px' }}>{Math.round(brushSettings.opacity * 100)}%</span>
          </div>

          <div>
            <label>Hardness: </label>
            <input
              type="range"
              min="0"
              max="100"
              value={brushSettings.hardness * 100}
              onChange={(e) => handleBrushSettingChange('hardness', Number(e.target.value) / 100)}
              style={{ width: '100px' }}
            />
            <span style={{ marginLeft: '5px' }}>{Math.round(brushSettings.hardness * 100)}%</span>
          </div>

          <div>
            <label>Flow: </label>
            <input
              type="range"
              min="0"
              max="100"
              value={brushSettings.flow * 100}
              onChange={(e) => handleBrushSettingChange('flow', Number(e.target.value) / 100)}
              style={{ width: '100px' }}
            />
            <span style={{ marginLeft: '5px' }}>{Math.round(brushSettings.flow * 100)}%</span>
          </div>
        </div>

        {/* Pressure dynamics */}
        <div style={{ 
          display: 'flex', 
          gap: '15px', 
          paddingLeft: '20px', 
          borderLeft: '1px solid #555' 
        }}>
          <div>
            <label>Size → Pressure: </label>
            <input
              type="range"
              min="0"
              max="100"
              value={brushSettings.dynamics.sizePressure * 100}
              onChange={(e) => handleBrushSettingChange('dynamics.sizePressure', Number(e.target.value) / 100)}
              style={{ width: '80px' }}
            />
            <span style={{ marginLeft: '5px' }}>{Math.round(brushSettings.dynamics.sizePressure * 100)}%</span>
          </div>

          <div>
            <label>Opacity → Pressure: </label>
            <input
              type="range"
              min="0"
              max="100"
              value={brushSettings.dynamics.opacityPressure * 100}
              onChange={(e) => handleBrushSettingChange('dynamics.opacityPressure', Number(e.target.value) / 100)}
              style={{ width: '80px' }}
            />
            <span style={{ marginLeft: '5px' }}>{Math.round(brushSettings.dynamics.opacityPressure * 100)}%</span>
          </div>
        </div>
      </div>
    </div>
  );
};
/**
 * Pressure Visualization Component
 * Displays real-time pressure data and device information
 */

import React, { useState, useEffect, useRef } from 'react';
import { inputDeviceManager, PressureData, InputDeviceInfo } from '../input/InputDeviceManager';

interface PressureVisualizationProps {
  isDrawing: boolean;
  currentPressure?: PressureData;
}

export const PressureVisualization: React.FC<PressureVisualizationProps> = ({ 
  isDrawing, 
  currentPressure 
}) => {
  const [deviceInfo, setDeviceInfo] = useState<InputDeviceInfo | null>(null);
  const [pressureHistory, setPressureHistory] = useState<number[]>([]);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const historyLength = 100;

  useEffect(() => {
    // Get initial device info
    setDeviceInfo(inputDeviceManager.getCurrentDevice());
    
    // Update device info when it changes
    const interval = setInterval(() => {
      setDeviceInfo(inputDeviceManager.getCurrentDevice());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    if (currentPressure && isDrawing) {
      setPressureHistory(prev => {
        const newHistory = [...prev, currentPressure.pressure];
        if (newHistory.length > historyLength) {
          newHistory.shift();
        }
        return newHistory;
      });
    }
  }, [currentPressure, isDrawing]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw pressure graph
    if (pressureHistory.length > 0) {
      ctx.strokeStyle = '#4CAF50';
      ctx.lineWidth = 2;
      ctx.beginPath();

      pressureHistory.forEach((pressure, index) => {
        const x = (index / historyLength) * canvas.width;
        const y = canvas.height - (pressure * canvas.height);
        
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      ctx.stroke();
    }

    // Draw grid
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    
    // Horizontal lines
    for (let i = 0; i <= 10; i++) {
      const y = (i / 10) * canvas.height;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
  }, [pressureHistory]);

  if (!deviceInfo) return null;

  return (
    <div style={{
      position: 'absolute',
      bottom: 20,
      right: 20,
      width: 300,
      background: 'rgba(0, 0, 0, 0.8)',
      color: 'white',
      padding: '15px',
      borderRadius: '8px',
      fontFamily: 'monospace',
      fontSize: '12px',
      boxShadow: '0 4px 8px rgba(0, 0, 0, 0.3)'
    }}>
      <h3 style={{ margin: '0 0 10px 0', fontSize: '14px' }}>Pressure Visualization</h3>
      
      {/* Device Info */}
      <div style={{ marginBottom: '10px' }}>
        <div>Device: {deviceInfo.vendor || 'Unknown'} {deviceInfo.type}</div>
        <div>Model: {deviceInfo.model || 'N/A'}</div>
        <div style={{ display: 'flex', gap: '10px', marginTop: '5px' }}>
          <span style={{ color: deviceInfo.supportsPressure ? '#4CAF50' : '#f44336' }}>
            Pressure: {deviceInfo.supportsPressure ? '✓' : '✗'}
          </span>
          <span style={{ color: deviceInfo.supportsTilt ? '#4CAF50' : '#f44336' }}>
            Tilt: {deviceInfo.supportsTilt ? '✓' : '✗'}
          </span>
          <span style={{ color: deviceInfo.supportsRotation ? '#4CAF50' : '#f44336' }}>
            Rotation: {deviceInfo.supportsRotation ? '✓' : '✗'}
          </span>
        </div>
      </div>

      {/* Current Values */}
      {currentPressure && isDrawing && (
        <div style={{ marginBottom: '10px' }}>
          <div>Pressure: {(currentPressure.pressure * 100).toFixed(1)}%</div>
          {currentPressure.tiltX !== undefined && (
            <div>Tilt: X={currentPressure.tiltX.toFixed(1)}° Y={currentPressure.tiltY?.toFixed(1)}°</div>
          )}
          {currentPressure.twist !== undefined && (
            <div>Rotation: {currentPressure.twist.toFixed(1)}°</div>
          )}
        </div>
      )}

      {/* Pressure Graph */}
      <canvas 
        ref={canvasRef}
        width={270}
        height={80}
        style={{
          background: 'rgba(255, 255, 255, 0.05)',
          borderRadius: '4px',
          marginTop: '10px'
        }}
      />
      
      <div style={{ 
        fontSize: '10px', 
        color: 'rgba(255, 255, 255, 0.6)', 
        marginTop: '5px' 
      }}>
        Real-time pressure graph (0-100%)
      </div>
    </div>
  );
};
/**
 * React Canvas Component for Genshi Studio
 */

import React, { useRef, useEffect, useState } from 'react';
import { GraphicsEngine } from '../graphics/engine/GraphicsEngine';
import { Color, BrushSettings } from '../types/graphics';
import { PatternType } from '../graphics/patterns/CulturalPatternGenerator';

interface CanvasProps {
  width?: number;
  height?: number;
  onEngineReady?: (engine: GraphicsEngine) => void;
}

export const Canvas: React.FC<CanvasProps> = ({ 
  width = 800, 
  height = 600,
  onEngineReady 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const engineRef = useRef<GraphicsEngine | null>(null);
  const [isReady, setIsReady] = useState(false);
  const [metrics, setMetrics] = useState<any>(null);

  useEffect(() => {
    if (!canvasRef.current) return;

    // Initialize graphics engine
    const engine = new GraphicsEngine({
      canvas: canvasRef.current,
      width,
      height
    });

    engineRef.current = engine;
    setIsReady(true);

    if (onEngineReady) {
      onEngineReady(engine);
    }

    // Set up performance monitoring
    const metricsInterval = setInterval(() => {
      if (engineRef.current) {
        setMetrics(engineRef.current.getPerformanceMetrics());
      }
    }, 1000);

    return () => {
      clearInterval(metricsInterval);
      engine.destroy();
    };
  }, [width, height, onEngineReady]);

  return (
    <div className="canvas-container" style={{ position: 'relative' }}>
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        style={{
          display: 'block',
          border: '1px solid #ccc',
          cursor: 'crosshair',
          touchAction: 'none' // Prevent default touch behaviors
        }}
      />
      
      {/* Performance overlay */}
      {process.env.NODE_ENV === 'development' && metrics && (
        <div
          style={{
            position: 'absolute',
            top: 10,
            right: 10,
            background: 'rgba(0, 0, 0, 0.7)',
            color: 'white',
            padding: '10px',
            fontFamily: 'monospace',
            fontSize: '12px',
            borderRadius: '4px'
          }}
        >
          <div>FPS: {metrics.fps}</div>
          <div>Frame: {metrics.frameCount}</div>
          <div>Objects: {metrics.canvasMetrics?.visibleCount}/{metrics.canvasMetrics?.objectCount}</div>
          <div>Memory: {(metrics.canvasMetrics?.memoryUsage / 1024 / 1024).toFixed(1)}MB</div>
        </div>
      )}
    </div>
  );
};

// Toolbar component for tools and settings
interface ToolbarProps {
  engine: GraphicsEngine | null;
}

export const Toolbar: React.FC<ToolbarProps> = ({ engine }) => {
  const [currentColor, setCurrentColor] = useState<Color>({ r: 0, g: 0, b: 0, a: 1 });
  const [brushSettings, setBrushSettings] = useState<BrushSettings>({
    size: 10,
    hardness: 0.8,
    opacity: 1.0,
    flow: 1.0,
    smoothing: 0.5,
    pressureSensitivity: {
      size: true,
      opacity: true,
      flow: true
    }
  });

  const handleColorChange = (color: Color) => {
    setCurrentColor(color);
    engine?.setColor(color);
  };

  const handleBrushSettingChange = (setting: keyof BrushSettings, value: any) => {
    const newSettings = { ...brushSettings, [setting]: value };
    setBrushSettings(newSettings);
    engine?.updateBrushSettings(newSettings);
  };

  const tools = [
    { id: 'brush', name: 'Brush', icon: '🖌️', action: () => engine?.selectBrushTool() },
    { id: 'eraser', name: 'Eraser', icon: '🧹', action: () => engine?.selectEraserTool() },
    { id: 'pattern', name: 'Pattern', icon: '🔲', action: () => engine?.selectPatternTool() }
  ];

  return (
    <div className="toolbar" style={{
      display: 'flex',
      gap: '10px',
      padding: '10px',
      background: '#f0f0f0',
      borderBottom: '1px solid #ccc'
    }}>
      {/* Tool buttons */}
      <div className="tool-buttons" style={{ display: 'flex', gap: '5px' }}>
        {tools.map(tool => (
          <button
            key={tool.id}
            onClick={tool.action}
            title={tool.name}
            style={{
              width: '40px',
              height: '40px',
              fontSize: '20px',
              border: '1px solid #ccc',
              background: 'white',
              cursor: 'pointer',
              borderRadius: '4px'
            }}
          >
            {tool.icon}
          </button>
        ))}
      </div>

      {/* Color picker */}
      <div className="color-picker" style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
        <label>Color:</label>
        <input
          type="color"
          value={`#${Math.round(currentColor.r * 255).toString(16).padStart(2, '0')}${Math.round(currentColor.g * 255).toString(16).padStart(2, '0')}${Math.round(currentColor.b * 255).toString(16).padStart(2, '0')}`}
          onChange={(e) => {
            const hex = e.target.value;
            const r = parseInt(hex.substr(1, 2), 16) / 255;
            const g = parseInt(hex.substr(3, 2), 16) / 255;
            const b = parseInt(hex.substr(5, 2), 16) / 255;
            handleColorChange({ r, g, b, a: currentColor.a });
          }}
        />
      </div>

      {/* Brush settings */}
      <div className="brush-settings" style={{ display: 'flex', gap: '10px' }}>
        <div>
          <label>Size: </label>
          <input
            type="range"
            min="1"
            max="100"
            value={brushSettings.size}
            onChange={(e) => handleBrushSettingChange('size', Number(e.target.value))}
          />
          <span>{brushSettings.size}px</span>
        </div>

        <div>
          <label>Opacity: </label>
          <input
            type="range"
            min="0"
            max="100"
            value={brushSettings.opacity * 100}
            onChange={(e) => handleBrushSettingChange('opacity', Number(e.target.value) / 100)}
          />
          <span>{Math.round(brushSettings.opacity * 100)}%</span>
        </div>

        <div>
          <label>Hardness: </label>
          <input
            type="range"
            min="0"
            max="100"
            value={brushSettings.hardness * 100}
            onChange={(e) => handleBrushSettingChange('hardness', Number(e.target.value) / 100)}
          />
          <span>{Math.round(brushSettings.hardness * 100)}%</span>
        </div>
      </div>
    </div>
  );
};

// Pattern panel component
interface PatternPanelProps {
  engine: GraphicsEngine | null;
}

export const PatternPanel: React.FC<PatternPanelProps> = ({ engine }) => {
  const patterns = [
    { type: PatternType.Ichimatsu, name: 'Ichimatsu (市松)', description: 'Checkerboard' },
    { type: PatternType.Seigaiha, name: 'Seigaiha (青海波)', description: 'Waves' },
    { type: PatternType.Asanoha, name: 'Asanoha (麻の葉)', description: 'Hemp leaf' },
    { type: PatternType.Shippo, name: 'Shippo (七宝)', description: 'Seven treasures' },
    { type: PatternType.Kagome, name: 'Kagome (籠目)', description: 'Basket weave' },
    { type: PatternType.Kikkoumon, name: 'Kikkoumon (亀甲文)', description: 'Tortoise shell' },
    { type: PatternType.Sayagata, name: 'Sayagata (紗綾形)', description: 'Key fret' },
    { type: PatternType.Tatewaku, name: 'Tatewaku (立涌)', description: 'Rising steam' }
  ];

  const handlePatternClick = (type: PatternType) => {
    if (!engine) return;

    // Generate pattern at center of canvas
    engine.generatePattern(
      type,
      { x: 100, y: 100, width: 200, height: 200 },
      {
        scale: 1,
        rotation: 0,
        color1: { r: 0, g: 0, b: 0, a: 1 },
        color2: { r: 1, g: 1, b: 1, a: 1 }
      }
    );
  };

  return (
    <div className="pattern-panel" style={{
      width: '200px',
      padding: '10px',
      background: '#f8f8f8',
      borderLeft: '1px solid #ccc',
      overflowY: 'auto'
    }}>
      <h3>Cultural Patterns</h3>
      <div className="pattern-list">
        {patterns.map(pattern => (
          <div
            key={pattern.type}
            className="pattern-item"
            onClick={() => handlePatternClick(pattern.type)}
            style={{
              padding: '10px',
              margin: '5px 0',
              background: 'white',
              border: '1px solid #ddd',
              borderRadius: '4px',
              cursor: 'pointer',
              transition: 'background 0.2s'
            }}
            onMouseEnter={(e) => e.currentTarget.style.background = '#f0f0f0'}
            onMouseLeave={(e) => e.currentTarget.style.background = 'white'}
          >
            <div style={{ fontWeight: 'bold' }}>{pattern.name}</div>
            <div style={{ fontSize: '12px', color: '#666' }}>{pattern.description}</div>
          </div>
        ))}
      </div>
    </div>
  );
};

// Main App component
export const GenshiStudioApp: React.FC = () => {
  const [engine, setEngine] = useState<GraphicsEngine | null>(null);

  return (
    <div className="genshi-studio-app" style={{
      display: 'flex',
      flexDirection: 'column',
      height: '100vh',
      overflow: 'hidden'
    }}>
      <Toolbar engine={engine} />
      
      <div style={{ display: 'flex', flex: 1 }}>
        <div style={{ flex: 1, overflow: 'hidden' }}>
          <Canvas onEngineReady={setEngine} />
        </div>
        <PatternPanel engine={engine} />
      </div>
    </div>
  );
};
import React, { useState, useEffect } from 'react'
import { Wifi, WifiOff } from 'lucide-react'
import { cn } from '../lib/utils'

export function OfflineIndicator() {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  const [showIndicator, setShowIndicator] = useState(false)

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      // Show online indicator briefly
      setShowIndicator(true)
      setTimeout(() => setShowIndicator(false), 3000)
    }

    const handleOffline = () => {
      setIsOnline(false)
      setShowIndicator(true)
    }

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    // Show indicator if already offline
    if (!navigator.onLine) {
      handleOffline()
    }

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  if (!showIndicator) return null

  return (
    <div
      data-testid="offline-indicator"
      className={cn(
        'fixed top-4 left-1/2 -translate-x-1/2 z-50',
        'px-4 py-2 rounded-lg shadow-lg',
        'flex items-center gap-2 text-sm font-medium',
        'transition-all duration-300 animate-in fade-in slide-in-from-top-2',
        isOnline
          ? 'bg-green-500 text-white'
          : 'bg-red-500 text-white'
      )}
    >
      {isOnline ? (
        <>
          <Wifi className="w-4 h-4" />
          <span>Back online</span>
        </>
      ) : (
        <>
          <WifiOff className="w-4 h-4" />
          <span>You are offline</span>
        </>
      )}
    </div>
  )
}
import React, { useRef } from 'react'
import { Canvas } from '../components/studio/Canvas'
import { Toolbar } from '../components/studio/Toolbar'
import { CodeEditor } from '../components/studio/CodeEditor'
import { PatternSelector } from '../components/studio/PatternSelector'
import { ParametricPatternEditor } from '../components/studio/ParametricPatternEditor'
import { InteractiveGrowthStudio } from '../components/studio/InteractiveGrowthStudio'
import { ExportDialog } from '../components/studio/ExportDialog'
import { PresetDialog } from '../components/studio/PresetDialog'
import { BookmarkDialog } from '../components/studio/BookmarkDialog'
import { useAppStore } from '../hooks/useAppStore'
import { useKeyboardShortcuts } from '../hooks/useKeyboardShortcuts'

export function StudioPage() {
  const { 
    canvasMode, 
    exportDialogOpen, 
    setExportDialogOpen,
    presetDialogOpen,
    setPresetDialogOpen,
    bookmarkDialogOpen,
    setBookmarkDialogOpen
  } = useAppStore()
  const containerRef = useRef<HTMLDivElement>(null)
  const canvasRef = useRef<any>(null)
  
  // Initialize keyboard shortcuts
  useKeyboardShortcuts()

  return (
    <div ref={containerRef} className="flex flex-col h-full">
      {/* Toolbar */}
      <Toolbar />
      
      {/* Main studio area */}
      <div className="flex-1 relative overflow-hidden">
        {canvasMode === 'draw' ? (
          <>
            {/* Drawing canvas */}
            <Canvas ref={canvasRef} />
            
            {/* Pattern selector overlay */}
            <PatternSelector />
          </>
        ) : canvasMode === 'code' ? (
          /* Code editor mode */
          <CodeEditor />
        ) : canvasMode === 'parametric' ? (
          /* Parametric pattern editor mode */
          <ParametricPatternEditor />
        ) : (
          /* Interactive growth studio mode */
          <InteractiveGrowthStudio />
        )}
      </div>
      
      {/* Dialogs */}
      <ExportDialog 
        isOpen={exportDialogOpen} 
        onClose={() => setExportDialogOpen(false)}
        canvas={canvasRef.current}
      />
      
      <PresetDialog 
        isOpen={presetDialogOpen} 
        onClose={() => setPresetDialogOpen(false)}
      />
      
      <BookmarkDialog 
        isOpen={bookmarkDialogOpen} 
        onClose={() => setBookmarkDialogOpen(false)}
      />
    </div>
  )
}
import React, { useState } from 'react'
import { Search, Filter, Grid, List, Heart, Share2, Download } from 'lucide-react'
import { motion } from 'framer-motion'

interface GalleryItem {
  id: string
  title: string
  author: string
  date: string
  likes: number
  thumbnail: string
  tags: string[]
  pattern: string
}

// Mock gallery data showcasing cultural diversity
const galleryItems: GalleryItem[] = [
  {
    id: '1',
    title: 'Seigaiha - Blue Ocean Waves',
    author: 'Hiroshi Tanaka',
    date: '2024-01-15',
    likes: 234,
    thumbnail: '🌊',
    tags: ['japanese', 'seigaiha', 'blue', 'traditional'],
    pattern: 'seigaiha'
  },
  {
    id: '2',
    title: 'Ichimatsu - Checkered Pattern',
    author: 'Yuki Sato',
    date: '2024-01-14',
    likes: 189,
    thumbnail: '⬜',
    tags: ['japanese', 'ichimatsu', 'geometric', 'classic'],
    pattern: 'ichimatsu'
  },
  {
    id: '3',
    title: 'Asanoha - Hemp Leaf Pattern',
    author: 'Kenji Nakamura',
    date: '2024-01-13',
    likes: 312,
    thumbnail: '🍃',
    tags: ['japanese', 'asanoha', 'green', 'nature'],
    pattern: 'asanoha'
  },
  {
    id: '4',
    title: 'Sakura - Cherry Blossom Dance',
    author: 'Mei Yoshida',
    date: '2024-01-12',
    likes: 156,
    thumbnail: '🌸',
    tags: ['japanese', 'sakura', 'pink', 'spring'],
    pattern: 'sakura'
  },
  {
    id: '5',
    title: 'Shippo - Seven Treasures',
    author: 'Akira Fujimoto',
    date: '2024-01-11',
    likes: 278,
    thumbnail: '💎',
    tags: ['japanese', 'shippo', 'circular', 'prosperity'],
    pattern: 'shippo'
  },
  {
    id: '6',
    title: 'Kumiko - Geometric Harmony',
    author: 'Takeshi Yamamoto',
    date: '2024-01-10',
    likes: 195,
    thumbnail: '⚪',
    tags: ['japanese', 'kumiko', 'woodwork', 'craft'],
    pattern: 'kumiko'
  },
  {
    id: '7',
    title: 'Celtic Knot - Eternal Bond',
    author: 'Fiona O\'Connor',
    date: '2024-01-09',
    likes: 203,
    thumbnail: '🔗',
    tags: ['celtic', 'knot', 'green', 'eternity'],
    pattern: 'celtic-knot'
  },
  {
    id: '8',
    title: 'Islamic Geometric - Star & Cross',
    author: 'Amara Hassan',
    date: '2024-01-08',
    likes: 289,
    thumbnail: '⭐',
    tags: ['islamic', 'geometric', 'gold', 'sacred'],
    pattern: 'islamic-geometric'
  },
  {
    id: '9',
    title: 'Aztec Sun - Solar Deity',
    author: 'Carlos Mendoza',
    date: '2024-01-07',
    likes: 167,
    thumbnail: '☀️',
    tags: ['aztec', 'sun', 'orange', 'ancient'],
    pattern: 'aztec-sun'
  },
  {
    id: '10',
    title: 'Mandala - Cosmic Circle',
    author: 'Priya Sharma',
    date: '2024-01-06',
    likes: 324,
    thumbnail: '🕉️',
    tags: ['mandala', 'cosmic', 'meditation', 'spiritual'],
    pattern: 'mandala'
  },
  {
    id: '11',
    title: 'Nordic Runes - Ancient Script',
    author: 'Erik Johansson',
    date: '2024-01-05',
    likes: 145,
    thumbnail: '⚡',
    tags: ['nordic', 'runes', 'ancient', 'mystical'],
    pattern: 'nordic-runes'
  },
  {
    id: '12',
    title: 'African Kente - Royal Weave',
    author: 'Kofi Asante',
    date: '2024-01-04',
    likes: 267,
    thumbnail: '🎨',
    tags: ['african', 'kente', 'colorful', 'royal'],
    pattern: 'african-kente'
  }
]

export function GalleryPage() {
  const [searchQuery, setSearchQuery] = useState('')
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid')
  const [selectedTags, setSelectedTags] = useState<string[]>([])

  const allTags = Array.from(
    new Set(galleryItems.flatMap(item => item.tags))
  )

  const filteredItems = galleryItems.filter(item => {
    const matchesSearch = item.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         item.author.toLowerCase().includes(searchQuery.toLowerCase())
    const matchesTags = selectedTags.length === 0 || 
                       selectedTags.some(tag => item.tags.includes(tag))
    return matchesSearch && matchesTags
  })

  const toggleTag = (tag: string) => {
    setSelectedTags(prev =>
      prev.includes(tag)
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    )
  }

  return (
    <div className="max-w-7xl mx-auto px-6 py-8">
      {/* Header */}
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">Pattern Gallery</h1>
        <p className="text-lg text-muted-foreground mb-4">
          Explore cultural patterns from around the world, created by the Genshi Studio community
        </p>
        <div className="bg-card border border-border rounded-lg p-4">
          <h2 className="text-xl font-semibold mb-2">Featured Collections</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div className="text-center">
              <div className="text-2xl mb-1">🇯🇵</div>
              <div className="text-sm font-medium">Japanese Patterns</div>
              <div className="text-xs text-muted-foreground">Traditional & Modern</div>
            </div>
            <div className="text-center">
              <div className="text-2xl mb-1">🕌</div>
              <div className="text-sm font-medium">Islamic Geometry</div>
              <div className="text-xs text-muted-foreground">Sacred Mathematics</div>
            </div>
            <div className="text-center">
              <div className="text-2xl mb-1">🍀</div>
              <div className="text-sm font-medium">Celtic Designs</div>
              <div className="text-xs text-muted-foreground">Eternal Knots</div>
            </div>
            <div className="text-center">
              <div className="text-2xl mb-1">🌍</div>
              <div className="text-sm font-medium">World Cultures</div>
              <div className="text-xs text-muted-foreground">Global Heritage</div>
            </div>
          </div>
        </div>
      </div>

      {/* Search and filters */}
      <div className="mb-8 space-y-4">
        {/* Search bar */}
        <div className="flex gap-4">
          <div className="flex-1 relative">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
            <input
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              placeholder="Search patterns..."
              className="w-full pl-10 pr-4 py-3 bg-card border border-border rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
            />
          </div>
          
          {/* View mode toggle */}
          <div className="flex gap-1 bg-card border border-border rounded-lg p-1">
            <button
              onClick={() => setViewMode('grid')}
              className={`p-2 rounded transition-colors ${
                viewMode === 'grid' 
                  ? 'bg-primary text-primary-foreground' 
                  : 'hover:bg-accent'
              }`}
              aria-label="Grid view"
            >
              <Grid className="h-5 w-5" />
            </button>
            <button
              onClick={() => setViewMode('list')}
              className={`p-2 rounded transition-colors ${
                viewMode === 'list' 
                  ? 'bg-primary text-primary-foreground' 
                  : 'hover:bg-accent'
              }`}
              aria-label="List view"
            >
              <List className="h-5 w-5" />
            </button>
          </div>
        </div>

        {/* Tag filters */}
        <div className="flex items-center gap-2 flex-wrap">
          <Filter className="h-4 w-4 text-muted-foreground" />
          {allTags.map(tag => (
            <button
              key={tag}
              onClick={() => toggleTag(tag)}
              className={`px-3 py-1 rounded-full text-sm transition-colors ${
                selectedTags.includes(tag)
                  ? 'bg-primary text-primary-foreground'
                  : 'bg-secondary hover:bg-secondary/80'
              }`}
            >
              {tag}
            </button>
          ))}
        </div>
      </div>

      {/* Gallery grid/list */}
      {viewMode === 'grid' ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
          {filteredItems.map((item, index) => (
            <motion.div
              key={item.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: index * 0.05 }}
              className="bg-card rounded-lg border border-border overflow-hidden hover:shadow-lg transition-shadow"
            >
              {/* Thumbnail */}
              <div className="aspect-square bg-gray-100 flex items-center justify-center text-6xl">
                {item.thumbnail}
              </div>
              
              {/* Info */}
              <div className="p-4">
                <h3 className="font-semibold mb-1">{item.title}</h3>
                <p className="text-sm text-muted-foreground mb-3">
                  by {item.author}
                </p>
                
                {/* Tags */}
                <div className="flex gap-1 flex-wrap mb-3">
                  {item.tags.slice(0, 3).map(tag => (
                    <span
                      key={tag}
                      className="px-2 py-0.5 bg-secondary text-xs rounded-full"
                    >
                      {tag}
                    </span>
                  ))}
                </div>
                
                {/* Actions */}
                <div className="flex items-center justify-between">
                  <button className="flex items-center gap-1 text-sm hover:text-primary transition-colors">
                    <Heart className="h-4 w-4" />
                    <span>{item.likes}</span>
                  </button>
                  
                  <div className="flex gap-2">
                    <button
                      className="p-1.5 hover:bg-accent rounded transition-colors"
                      aria-label="Share"
                    >
                      <Share2 className="h-4 w-4" />
                    </button>
                    <button
                      className="p-1.5 hover:bg-accent rounded transition-colors"
                      aria-label="Download"
                    >
                      <Download className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              </div>
            </motion.div>
          ))}
        </div>
      ) : (
        <div className="space-y-4">
          {filteredItems.map((item, index) => (
            <motion.div
              key={item.id}
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: index * 0.05 }}
              className="bg-card rounded-lg border border-border p-4 hover:shadow-lg transition-shadow flex gap-4"
            >
              {/* Thumbnail */}
              <div className="w-24 h-24 bg-gray-100 rounded-lg flex items-center justify-center text-4xl flex-shrink-0">
                {item.thumbnail}
              </div>
              
              {/* Info */}
              <div className="flex-1">
                <div className="flex items-start justify-between mb-2">
                  <div>
                    <h3 className="font-semibold text-lg">{item.title}</h3>
                    <p className="text-sm text-muted-foreground">
                      by {item.author} • {new Date(item.date).toLocaleDateString()}
                    </p>
                  </div>
                  
                  <div className="flex items-center gap-4">
                    <button className="flex items-center gap-1 text-sm hover:text-primary transition-colors">
                      <Heart className="h-4 w-4" />
                      <span>{item.likes}</span>
                    </button>
                    
                    <div className="flex gap-2">
                      <button
                        className="p-1.5 hover:bg-accent rounded transition-colors"
                        aria-label="Share"
                      >
                        <Share2 className="h-4 w-4" />
                      </button>
                      <button
                        className="p-1.5 hover:bg-accent rounded transition-colors"
                        aria-label="Download"
                      >
                        <Download className="h-4 w-4" />
                      </button>
                    </div>
                  </div>
                </div>
                
                {/* Tags */}
                <div className="flex gap-1 flex-wrap">
                  {item.tags.map(tag => (
                    <span
                      key={tag}
                      className="px-2 py-0.5 bg-secondary text-xs rounded-full"
                    >
                      {tag}
                    </span>
                  ))}
                </div>
              </div>
            </motion.div>
          ))}
        </div>
      )}
    </div>
  )
}
/**
 * Pressure Test Page - Demonstrates pressure-sensitive input capabilities
 */

import React, { useState } from 'react';
import { EnhancedCanvas, EnhancedToolbar } from '../components/EnhancedCanvas';
import { GraphicsEngine } from '../graphics/engine/GraphicsEngine';

export const PressureTestPage: React.FC = () => {
  const [engine, setEngine] = useState<GraphicsEngine | null>(null);
  const [deviceInfo, setDeviceInfo] = useState<any>(null);

  const handleEngineReady = (engineInstance: GraphicsEngine) => {
    setEngine(engineInstance);
    
    // Get device info
    const info = engineInstance.getInputDeviceInfo();
    setDeviceInfo(info);
  };

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      height: '100vh',
      background: '#1a1a1a',
      color: 'white',
      overflow: 'hidden'
    }}>
      {/* Header */}
      <header style={{
        padding: '20px',
        background: '#2a2a2a',
        borderBottom: '1px solid #444'
      }}>
        <h1 style={{ margin: 0, fontSize: '24px' }}>Genshi Studio - Pressure-Sensitive Drawing</h1>
        <p style={{ margin: '5px 0 0 0', fontSize: '14px', color: '#aaa' }}>
          Professional digital art with tablet support
        </p>
      </header>

      {/* Enhanced Toolbar */}
      <EnhancedToolbar engine={engine} />

      {/* Main Content */}
      <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
        {/* Left Sidebar - Instructions */}
        <aside style={{
          width: '300px',
          padding: '20px',
          background: '#2a2a2a',
          borderRight: '1px solid #444',
          overflowY: 'auto'
        }}>
          <h2 style={{ fontSize: '18px', marginBottom: '15px' }}>Quick Start Guide</h2>
          
          <section style={{ marginBottom: '20px' }}>
            <h3 style={{ fontSize: '14px', marginBottom: '10px' }}>Supported Devices</h3>
            <ul style={{ fontSize: '12px', lineHeight: '1.8', paddingLeft: '20px' }}>
              <li>✓ Wacom Tablets (Intuos, Cintiq, etc.)</li>
              <li>✓ Apple Pencil (iPad Pro/Air)</li>
              <li>✓ Surface Pen (Surface Pro/Studio)</li>
              <li>✓ Huion Tablets</li>
              <li>✓ XP-Pen Devices</li>
              <li>✓ Most pressure-sensitive styluses</li>
            </ul>
          </section>

          <section style={{ marginBottom: '20px' }}>
            <h3 style={{ fontSize: '14px', marginBottom: '10px' }}>Keyboard Shortcuts</h3>
            <div style={{ fontSize: '12px', lineHeight: '1.8' }}>
              <div><kbd>B</kbd> - Brush Tool</div>
              <div><kbd>E</kbd> - Eraser Tool</div>
              <div><kbd>G</kbd> - Pattern Tool</div>
              <div><kbd>[</kbd> - Decrease Brush Size</div>
              <div><kbd>]</kbd> - Increase Brush Size</div>
              <div><kbd>Space</kbd> - Pan Canvas (hold)</div>
            </div>
          </section>

          <section style={{ marginBottom: '20px' }}>
            <h3 style={{ fontSize: '14px', marginBottom: '10px' }}>Pressure Features</h3>
            <div style={{ fontSize: '12px', lineHeight: '1.8' }}>
              <p><strong>Size Variation:</strong> Brush size responds to pen pressure</p>
              <p><strong>Opacity Control:</strong> Lighter pressure = more transparent</p>
              <p><strong>Tilt Support:</strong> Angle affects brush shape (supported devices)</p>
              <p><strong>Rotation:</strong> Pen rotation changes brush angle (select devices)</p>
              <p><strong>Velocity Sensing:</strong> Fast strokes create different effects</p>
            </div>
          </section>

          <section>
            <h3 style={{ fontSize: '14px', marginBottom: '10px' }}>Current Device</h3>
            {deviceInfo ? (
              <div style={{ fontSize: '12px', background: '#1a1a1a', padding: '10px', borderRadius: '4px' }}>
                <div>Type: {deviceInfo.type}</div>
                <div>Vendor: {deviceInfo.vendor || 'Unknown'}</div>
                <div>Pressure: {deviceInfo.supportsPressure ? '✓' : '✗'}</div>
                <div>Tilt: {deviceInfo.supportsTilt ? '✓' : '✗'}</div>
                <div>Rotation: {deviceInfo.supportsRotation ? '✓' : '✗'}</div>
              </div>
            ) : (
              <div style={{ fontSize: '12px', color: '#666' }}>No device detected</div>
            )}
          </section>
        </aside>

        {/* Canvas Area */}
        <main style={{ flex: 1, position: 'relative', background: '#333' }}>
          <EnhancedCanvas onEngineReady={handleEngineReady} />
        </main>
      </div>

      {/* Footer */}
      <footer style={{
        padding: '10px 20px',
        background: '#2a2a2a',
        borderTop: '1px solid #444',
        fontSize: '12px',
        color: '#888'
      }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <span>Genshi Studio v1.0 - Professional Digital Art Software</span>
          <span>For best results, use a pressure-sensitive tablet</span>
        </div>
      </footer>
    </div>
  );
};
