/**
 * Translation Layers for Genshi Studio Synchronization Engine
 * Handles conversion between Draw, Parametric, Code, and Growth mode representations
 */

import { SyncChange, ModeType, ChangeType, SyncPriority } from './SynchronizationEngine'

// Type definitions for each mode's data structures
export interface DrawStroke {
  id: string
  points: { x: number; y: number; pressure?: number }[]
  color: string
  width: number
  opacity: number
  timestamp: number
}

export interface DrawData {
  strokes: DrawStroke[]
  layers: any[]
  canvas?: {
    width: number
    height: number
    background: string
  }
}

export interface ParametricPattern {
  type: 'ichimatsu' | 'seigaiha' | 'asanoha' | 'shippo' | 'yamaji'
  size: number
  density: number
  rotation: number
  colors: {
    primary: string
    secondary: string
    accent: string
  }
  opacity: number
}

export interface ParametricData {
  patterns: ParametricPattern[]
  parameters: Record<string, any>
  activePattern?: ParametricPattern
}

export interface CodeData {
  code: string
  executionResult?: {
    success: boolean
    output?: any
    errors?: string[]
    generatedShapes?: any[]
  }
  lastExecution?: number
}

export interface GrowthData {
  algorithm: 'organic' | 'l-system' | 'cellular-automata' | 'reaction-diffusion'
  parameters: Record<string, any>
  points: Set<string> | { x: number; y: number }[]
  generation: number
  settings: {
    growthRate: number
    density: number
    colors: {
      primary: string
      secondary: string
      accent: string
    }
    interactive: boolean
  }
}

/**
 * Translation layer manager
 */
export class TranslationLayers {
  
  /**
   * Translate Draw mode changes to Parametric mode
   */
  static async drawToParametric(change: SyncChange): Promise<SyncChange[]> {
    if (change.sourceMode !== ModeType.DRAW) return []
    
    const drawData: DrawData = change.data
    const translatedChanges: SyncChange[] = []
    
    try {
      // Analyze drawing patterns to extract parametric values
      const analysisResult = this.analyzeDrawingPatterns(drawData)
      
      if (analysisResult.patterns.length > 0) {
        const parametricChange: SyncChange = {
          id: `draw-to-parametric-${change.id}`,
          timestamp: Date.now(),
          sourceMode: ModeType.PARAMETRIC,
          changeType: ChangeType.PARAMETER_CHANGED,
          priority: SyncPriority.DERIVED_CHANGE,
          data: {
            patterns: analysisResult.patterns,
            parameters: analysisResult.extractedParameters,
            derivedFrom: 'draw_analysis'
          },
          metadata: {
            causedBy: change.id,
            confidence: analysisResult.confidence
          }
        }
        
        translatedChanges.push(parametricChange)
      }
      
    } catch (error) {
      console.error('❌ Draw to Parametric translation error:', error)
    }
    
    return translatedChanges
  }
  
  /**
   * Translate Parametric mode changes to Code mode
   */
  static async parametricToCode(change: SyncChange): Promise<SyncChange[]> {
    if (change.sourceMode !== ModeType.PARAMETRIC) return []
    
    const parametricData: ParametricData = change.data
    const translatedChanges: SyncChange[] = []
    
    try {
      // Generate code based on parametric patterns
      const generatedCode = this.generateCodeFromParametrics(parametricData)
      
      if (generatedCode) {
        const codeChange: SyncChange = {
          id: `parametric-to-code-${change.id}`,
          timestamp: Date.now(),
          sourceMode: ModeType.CODE,
          changeType: ChangeType.CODE_EXECUTED,
          priority: SyncPriority.DERIVED_CHANGE,
          data: {
            code: generatedCode,
            autoGenerated: true,
            source: 'parametric_translation'
          },
          metadata: {
            causedBy: change.id,
            parametricPattern: parametricData.activePattern?.type
          }
        }
        
        translatedChanges.push(codeChange)
      }
      
    } catch (error) {
      console.error('❌ Parametric to Code translation error:', error)
    }
    
    return translatedChanges
  }
  
  /**
   * Translate Code mode changes to visual representation
   */
  static async codeToVisual(change: SyncChange): Promise<SyncChange[]> {
    if (change.sourceMode !== ModeType.CODE) return []
    
    const codeData: CodeData = change.data
    const translatedChanges: SyncChange[] = []
    
    try {
      // Parse code execution results to create visual elements
      if (codeData.executionResult?.success && codeData.executionResult.generatedShapes) {
        
        // Convert to draw strokes
        const drawChange = this.codeResultsToDrawStrokes(codeData, change.id)
        if (drawChange) {
          translatedChanges.push(drawChange)
        }
        
        // Extract parametric patterns if recognizable
        const parametricChange = this.codeResultsToParametric(codeData, change.id)
        if (parametricChange) {
          translatedChanges.push(parametricChange)
        }
        
        // Check for growth-like behavior
        const growthChange = this.codeResultsToGrowth(codeData, change.id)
        if (growthChange) {
          translatedChanges.push(growthChange)
        }
      }
      
    } catch (error) {
      console.error('❌ Code to Visual translation error:', error)
    }
    
    return translatedChanges
  }
  
  /**
   * Translate Growth mode changes to other modes
   */
  static async growthToAll(change: SyncChange): Promise<SyncChange[]> {
    if (change.sourceMode !== ModeType.GROWTH) return []
    
    const growthData: GrowthData = change.data
    const translatedChanges: SyncChange[] = []
    
    try {
      // Convert growth points to draw strokes
      const drawChange = this.growthToDrawStrokes(growthData, change.id)
      if (drawChange) {
        translatedChanges.push(drawChange)
      }
      
      // Extract pattern parameters from growth settings
      const parametricChange = this.growthToParametric(growthData, change.id)
      if (parametricChange) {
        translatedChanges.push(parametricChange)
      }
      
      // Generate code representation of growth algorithm
      const codeChange = this.growthToCode(growthData, change.id)
      if (codeChange) {
        translatedChanges.push(codeChange)
      }
      
    } catch (error) {
      console.error('❌ Growth to All translation error:', error)
    }
    
    return translatedChanges
  }
  
  /**
   * Bidirectional translation dispatcher
   */
  static async translateChange(change: SyncChange): Promise<SyncChange[]> {
    const allChanges: SyncChange[] = []
    
    switch (change.sourceMode) {
      case ModeType.DRAW:
        allChanges.push(...await this.drawToParametric(change))
        // Also try to extract growth patterns from drawing
        allChanges.push(...await this.drawToGrowth(change))
        break
        
      case ModeType.PARAMETRIC:
        allChanges.push(...await this.parametricToCode(change))
        allChanges.push(...await this.parametricToGrowth(change))
        allChanges.push(...await this.parametricToDraw(change))
        break
        
      case ModeType.CODE:
        allChanges.push(...await this.codeToVisual(change))
        break
        
      case ModeType.GROWTH:
        allChanges.push(...await this.growthToAll(change))
        break
    }
    
    return allChanges
  }
  
  // Private helper methods for analysis and conversion
  
  private static analyzeDrawingPatterns(drawData: DrawData): {
    patterns: ParametricPattern[]
    extractedParameters: Record<string, any>
    confidence: number
  } {
    // Analyze strokes for repetitive patterns
    const strokes = drawData.strokes
    const patterns: ParametricPattern[] = []
    let confidence = 0
    
    if (strokes.length === 0) {
      return { patterns, extractedParameters: {}, confidence }
    }
    
    // Detect grid-like patterns (Ichimatsu)
    const gridPattern = this.detectGridPattern(strokes)
    if (gridPattern) {
      patterns.push(gridPattern)
      confidence += 0.3
    }
    
    // Detect wave patterns (Seigaiha)
    const wavePattern = this.detectWavePattern(strokes)
    if (wavePattern) {
      patterns.push(wavePattern)
      confidence += 0.4
    }
    
    // Extract common parameters
    const extractedParameters = {
      averageStrokeWidth: strokes.reduce((sum, s) => sum + s.width, 0) / strokes.length,
      dominantColor: this.findDominantColor(strokes),
      patternDensity: this.calculatePatternDensity(strokes),
      strokeCount: strokes.length
    }
    
    return { patterns, extractedParameters, confidence }
  }
  
  private static detectGridPattern(strokes: DrawStroke[]): ParametricPattern | null {
    // Simple grid detection based on stroke alignment
    const horizontalStrokes = strokes.filter(s => this.isHorizontal(s))
    const verticalStrokes = strokes.filter(s => this.isVertical(s))
    
    if (horizontalStrokes.length > 2 && verticalStrokes.length > 2) {
      const avgSpacing = this.calculateAverageSpacing(horizontalStrokes, verticalStrokes)
      const dominantColor = this.findDominantColor(strokes)
      
      return {
        type: 'ichimatsu',
        size: avgSpacing,
        density: 1.0,
        rotation: 0,
        colors: {
          primary: dominantColor,
          secondary: '#ffffff',
          accent: dominantColor
        },
        opacity: 1.0
      }
    }
    
    return null
  }
  
  private static detectWavePattern(strokes: DrawStroke[]): ParametricPattern | null {
    // Detect curved, wave-like strokes
    const curvedStrokes = strokes.filter(s => this.isCurved(s))
    
    if (curvedStrokes.length > 3) {
      const avgCurvature = this.calculateAverageCurvature(curvedStrokes)
      const dominantColor = this.findDominantColor(strokes)
      
      return {
        type: 'seigaiha',
        size: avgCurvature * 20, // Scale factor
        density: curvedStrokes.length / 10,
        rotation: 0,
        colors: {
          primary: dominantColor,
          secondary: '#f0f0f0',
          accent: dominantColor
        },
        opacity: 0.8
      }
    }
    
    return null
  }
  
  private static generateCodeFromParametrics(parametricData: ParametricData): string {
    if (!parametricData.activePattern) return ''
    
    const pattern = parametricData.activePattern
    
    // Generate Genshi API code based on pattern type
    switch (pattern.type) {
      case 'ichimatsu':
        return this.generateIchimatsuCode(pattern)
      case 'seigaiha':
        return this.generateSeigaihaCode(pattern)
      case 'asanoha':
        return this.generateAsanohaCode(pattern)
      case 'shippo':
        return this.generateShippoCode(pattern)
      case 'yamaji':
        return this.generateYamajiCode(pattern)
      default:
        return ''
    }
  }
  
  private static generateIchimatsuCode(pattern: ParametricPattern): string {
    return `// Auto-generated Ichimatsu pattern
canvas.background('${pattern.colors.secondary}')
draw.fill('${pattern.colors.primary}')
draw.noStroke()

const size = ${pattern.size}
const density = ${pattern.density}

for (let x = 0; x < canvas.width; x += size) {
  for (let y = 0; y < canvas.height; y += size) {
    const colorIndex = (Math.floor(x / size) + Math.floor(y / size)) % 2
    if (colorIndex === 1) {
      shapes.rect(x, y, size, size)
    }
  }
}`
  }
  
  private static generateSeigaihaCode(pattern: ParametricPattern): string {
    return `// Auto-generated Seigaiha (wave) pattern
canvas.background('${pattern.colors.secondary}')
draw.stroke('${pattern.colors.primary}')
draw.strokeWidth(2)
draw.noFill()

const radius = ${pattern.size}
const spacing = radius * 2

for (let x = 0; x < canvas.width + radius; x += spacing) {
  for (let y = 0; y < canvas.height + radius; y += spacing) {
    for (let r = 5; r < radius; r += radius / 3) {
      // Draw semicircle waves
      shapes.arc(x, y, r * 2, r * 2, 0, Math.PI)
    }
  }
}`
  }
  
  private static generateAsanohaCode(pattern: ParametricPattern): string {
    return `// Auto-generated Asanoha (hemp leaf) pattern
canvas.background('${pattern.colors.secondary}')
draw.stroke('${pattern.colors.primary}')
draw.strokeWidth(2)
draw.noFill()

const size = ${pattern.size}

for (let x = 0; x < canvas.width; x += size) {
  for (let y = 0; y < canvas.height; y += size) {
    // Draw hexagonal hemp leaf pattern
    const cx = x + size / 2
    const cy = y + size / 2
    const radius = size / 3
    
    // Hexagon outline
    shapes.polygon(
      cx + radius, cy,
      cx + radius/2, cy - radius * 0.866,
      cx - radius/2, cy - radius * 0.866,
      cx - radius, cy,
      cx - radius/2, cy + radius * 0.866,
      cx + radius/2, cy + radius * 0.866
    )
    
    // Internal lines
    shapes.line(cx, cy - radius, cx, cy + radius)
    shapes.line(cx - radius * 0.866, cy - radius/2, cx + radius * 0.866, cy + radius/2)
    shapes.line(cx - radius * 0.866, cy + radius/2, cx + radius * 0.866, cy - radius/2)
  }
}`
  }
  
  private static generateShippoCode(pattern: ParametricPattern): string {
    return `// Auto-generated Shippo (seven treasures) pattern
canvas.background('${pattern.colors.secondary}')
draw.stroke('${pattern.colors.primary}')
draw.strokeWidth(2)
draw.fill('${pattern.colors.accent}')

const size = ${pattern.size}
const radius = size / 2

for (let x = 0; x < canvas.width; x += size) {
  for (let y = 0; y < canvas.height; y += size) {
    const cx = x + size / 2
    const cy = y + size / 2
    
    // Overlapping circles
    shapes.circle(cx, cy, radius)
    
    // Intersection decoration
    draw.fill('${pattern.colors.accent}')
    shapes.circle(cx, cy, radius / 3)
  }
}`
  }
  
  private static generateYamajiCode(pattern: ParametricPattern): string {
    return `// Auto-generated Yamaji (mountain path) pattern
canvas.background('${pattern.colors.secondary}')
draw.stroke('${pattern.colors.primary}')
draw.strokeWidth(2)
draw.noFill()

const size = ${pattern.size}

for (let x = 0; x < canvas.width; x += size) {
  for (let y = 0; y < canvas.height; y += size) {
    // Diagonal mountain path lines
    shapes.line(x, y, x + size, y + size)
    shapes.line(x + size, y, x, y + size)
    
    // Central accent point
    draw.fill('${pattern.colors.accent}')
    shapes.circle(x + size/2, y + size/2, 3)
    draw.noFill()
  }
}`
  }
  
  private static codeResultsToDrawStrokes(codeData: CodeData, originalChangeId: string): SyncChange | null {
    if (!codeData.executionResult?.generatedShapes) return null
    
    const strokes: DrawStroke[] = []
    
    // Convert generated shapes to draw strokes
    for (const shape of codeData.executionResult.generatedShapes) {
      const stroke = this.shapeToStroke(shape)
      if (stroke) {
        strokes.push(stroke)
      }
    }
    
    if (strokes.length === 0) return null
    
    return {
      id: `code-to-draw-${originalChangeId}`,
      timestamp: Date.now(),
      sourceMode: ModeType.DRAW,
      changeType: ChangeType.STROKE_ADDED,
      priority: SyncPriority.DERIVED_CHANGE,
      data: { strokes },
      metadata: { causedBy: originalChangeId }
    }
  }
  
  private static codeResultsToParametric(codeData: CodeData, originalChangeId: string): SyncChange | null {
    // Try to extract parametric patterns from code
    const codeText = codeData.code.toLowerCase()
    
    let detectedPattern: ParametricPattern | null = null
    
    if (codeText.includes('ichimatsu') || (codeText.includes('rect') && codeText.includes('grid'))) {
      detectedPattern = this.extractParametricFromCode(codeText, 'ichimatsu')
    } else if (codeText.includes('seigaiha') || codeText.includes('arc')) {
      detectedPattern = this.extractParametricFromCode(codeText, 'seigaiha')
    } else if (codeText.includes('asanoha') || codeText.includes('hexagon')) {
      detectedPattern = this.extractParametricFromCode(codeText, 'asanoha')
    }
    
    if (!detectedPattern) return null
    
    return {
      id: `code-to-parametric-${originalChangeId}`,
      timestamp: Date.now(),
      sourceMode: ModeType.PARAMETRIC,
      changeType: ChangeType.PARAMETER_CHANGED,
      priority: SyncPriority.DERIVED_CHANGE,
      data: { activePattern: detectedPattern },
      metadata: { causedBy: originalChangeId }
    }
  }
  
  private static codeResultsToGrowth(codeData: CodeData, originalChangeId: string): SyncChange | null {
    const codeText = codeData.code.toLowerCase()
    
    // Detect growth-like patterns in code
    if (codeText.includes('random') || codeText.includes('noise') || codeText.includes('generation')) {
      const growthData: GrowthData = {
        algorithm: 'organic',
        parameters: this.extractGrowthParametersFromCode(codeText),
        points: [],
        generation: 0,
        settings: {
          growthRate: 0.02,
          density: 0.5,
          colors: {
            primary: '#000000',
            secondary: '#00ff00',
            accent: '#ff0000'
          },
          interactive: false
        }
      }
      
      return {
        id: `code-to-growth-${originalChangeId}`,
        timestamp: Date.now(),
        sourceMode: ModeType.GROWTH,
        changeType: ChangeType.GROWTH_UPDATED,
        priority: SyncPriority.DERIVED_CHANGE,
        data: growthData,
        metadata: { causedBy: originalChangeId }
      }
    }
    
    return null
  }
  
  private static growthToDrawStrokes(growthData: GrowthData, originalChangeId: string): SyncChange | null {
    const strokes: DrawStroke[] = []
    
    // Convert growth points to strokes
    if (Array.isArray(growthData.points)) {
      const points = growthData.points as { x: number; y: number }[]
      
      if (points.length > 1) {
        const stroke: DrawStroke = {
          id: `growth-stroke-${Date.now()}`,
          points: points.map(p => ({ x: p.x, y: p.y })),
          color: growthData.settings.colors.secondary,
          width: 2,
          opacity: 0.8,
          timestamp: Date.now()
        }
        strokes.push(stroke)
      }
    }
    
    if (strokes.length === 0) return null
    
    return {
      id: `growth-to-draw-${originalChangeId}`,
      timestamp: Date.now(),
      sourceMode: ModeType.DRAW,
      changeType: ChangeType.STROKE_ADDED,
      priority: SyncPriority.DERIVED_CHANGE,
      data: { strokes },
      metadata: { causedBy: originalChangeId }
    }
  }
  
  private static growthToParametric(growthData: GrowthData, originalChangeId: string): SyncChange | null {
    // Map growth algorithms to parametric patterns
    let patternType: 'ichimatsu' | 'seigaiha' | 'asanoha' | 'shippo' | 'yamaji'
    
    switch (growthData.algorithm) {
      case 'cellular-automata':
        patternType = 'ichimatsu'
        break
      case 'organic':
        patternType = 'seigaiha'
        break
      case 'l-system':
        patternType = 'asanoha'
        break
      case 'reaction-diffusion':
        patternType = 'shippo'
        break
      default:
        patternType = 'yamaji'
    }
    
    const pattern: ParametricPattern = {
      type: patternType,
      size: (growthData.parameters.size as number) || 30,
      density: growthData.settings.density,
      rotation: 0,
      colors: growthData.settings.colors,
      opacity: 0.8
    }
    
    return {
      id: `growth-to-parametric-${originalChangeId}`,
      timestamp: Date.now(),
      sourceMode: ModeType.PARAMETRIC,
      changeType: ChangeType.PARAMETER_CHANGED,
      priority: SyncPriority.DERIVED_CHANGE,
      data: { activePattern: pattern },
      metadata: { causedBy: originalChangeId }
    }
  }
  
  private static growthToCode(growthData: GrowthData, originalChangeId: string): SyncChange | null {
    const codeTemplate = this.generateGrowthAlgorithmCode(growthData)
    
    return {
      id: `growth-to-code-${originalChangeId}`,
      timestamp: Date.now(),
      sourceMode: ModeType.CODE,
      changeType: ChangeType.CODE_EXECUTED,
      priority: SyncPriority.DERIVED_CHANGE,
      data: {
        code: codeTemplate,
        autoGenerated: true,
        source: 'growth_translation'
      },
      metadata: { causedBy: originalChangeId }
    }
  }
  
  private static async drawToGrowth(change: SyncChange): Promise<SyncChange[]> {
    // Convert drawing strokes to growth patterns
    const drawData: DrawData = change.data
    
    if (drawData.strokes.length === 0) return []
    
    // Analyze drawing for growth-like behavior
    const isGrowthLike = this.detectGrowthLikeDrawing(drawData)
    if (!isGrowthLike) return []
    
    const growthData: GrowthData = {
      algorithm: 'organic',
      parameters: this.extractGrowthFromDrawing(drawData),
      points: this.convertStrokesToGrowthPoints(drawData.strokes),
      generation: 0,
      settings: {
        growthRate: 0.02,
        density: 0.5,
        colors: {
          primary: '#000000',
          secondary: drawData.strokes[0]?.color || '#00ff00',
          accent: '#ff0000'
        },
        interactive: true
      }
    }
    
    return [{
      id: `draw-to-growth-${change.id}`,
      timestamp: Date.now(),
      sourceMode: ModeType.GROWTH,
      changeType: ChangeType.GROWTH_UPDATED,
      priority: SyncPriority.DERIVED_CHANGE,
      data: growthData,
      metadata: { causedBy: change.id }
    }]
  }
  
  private static async parametricToGrowth(change: SyncChange): Promise<SyncChange[]> {
    // Convert parametric patterns to growth algorithms
    const parametricData: ParametricData = change.data
    
    if (!parametricData.activePattern) return []
    
    const pattern = parametricData.activePattern
    const algorithm = this.mapPatternToGrowthAlgorithm(pattern.type)
    
    const growthData: GrowthData = {
      algorithm,
      parameters: {
        size: pattern.size,
        density: pattern.density,
        rotation: pattern.rotation
      },
      points: [],
      generation: 0,
      settings: {
        growthRate: 0.02,
        density: pattern.density,
        colors: pattern.colors,
        interactive: false
      }
    }
    
    return [{
      id: `parametric-to-growth-${change.id}`,
      timestamp: Date.now(),
      sourceMode: ModeType.GROWTH,
      changeType: ChangeType.GROWTH_UPDATED,
      priority: SyncPriority.DERIVED_CHANGE,
      data: growthData,
      metadata: { causedBy: change.id }
    }]
  }
  
  private static async parametricToDraw(change: SyncChange): Promise<SyncChange[]> {
    // Convert parametric patterns to draw strokes
    const parametricData: ParametricData = change.data
    
    if (!parametricData.activePattern) return []
    
    const strokes = this.generateStrokesFromPattern(parametricData.activePattern)
    
    if (strokes.length === 0) return []
    
    return [{
      id: `parametric-to-draw-${change.id}`,
      timestamp: Date.now(),
      sourceMode: ModeType.DRAW,
      changeType: ChangeType.STROKE_ADDED,
      priority: SyncPriority.DERIVED_CHANGE,
      data: { strokes },
      metadata: { causedBy: change.id }
    }]
  }
  
  // Utility methods for pattern analysis and generation
  
  private static isHorizontal(stroke: DrawStroke): boolean {
    if (stroke.points.length < 2) return false
    const first = stroke.points[0]
    const last = stroke.points[stroke.points.length - 1]
    return Math.abs(first.y - last.y) < Math.abs(first.x - last.x) * 0.2
  }
  
  private static isVertical(stroke: DrawStroke): boolean {
    if (stroke.points.length < 2) return false
    const first = stroke.points[0]
    const last = stroke.points[stroke.points.length - 1]
    return Math.abs(first.x - last.x) < Math.abs(first.y - last.y) * 0.2
  }
  
  private static isCurved(stroke: DrawStroke): boolean {
    if (stroke.points.length < 3) return false
    
    let totalCurvature = 0
    for (let i = 1; i < stroke.points.length - 1; i++) {
      const prev = stroke.points[i - 1]
      const curr = stroke.points[i]
      const next = stroke.points[i + 1]
      
      const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x)
      const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x)
      const curvature = Math.abs(angle2 - angle1)
      
      totalCurvature += curvature
    }
    
    return totalCurvature > Math.PI / 4 // Arbitrary threshold for "curved"
  }
  
  private static calculateAverageSpacing(horizontalStrokes: DrawStroke[], verticalStrokes: DrawStroke[]): number {
    // Simple average of stroke spacing
    return 30 // Placeholder
  }
  
  private static calculateAverageCurvature(strokes: DrawStroke[]): number {
    // Calculate average curvature across all strokes
    return 1.5 // Placeholder
  }
  
  private static findDominantColor(strokes: DrawStroke[]): string {
    if (strokes.length === 0) return '#000000'
    
    const colorCounts = new Map<string, number>()
    
    for (const stroke of strokes) {
      const count = colorCounts.get(stroke.color) || 0
      colorCounts.set(stroke.color, count + 1)
    }
    
    let maxCount = 0
    let dominantColor = '#000000'
    
    for (const [color, count] of colorCounts) {
      if (count > maxCount) {
        maxCount = count
        dominantColor = color
      }
    }
    
    return dominantColor
  }
  
  private static calculatePatternDensity(strokes: DrawStroke[]): number {
    // Calculate relative density based on stroke distribution
    return Math.min(strokes.length / 100, 2.0)
  }
  
  private static shapeToStroke(shape: any): DrawStroke | null {
    // Convert generic shape to draw stroke
    return {
      id: `shape-stroke-${Date.now()}-${Math.random()}`,
      points: shape.points || [{ x: 0, y: 0 }],
      color: shape.color || '#000000',
      width: shape.strokeWidth || 2,
      opacity: shape.opacity || 1,
      timestamp: Date.now()
    }
  }
  
  private static extractParametricFromCode(code: string, patternType: string): ParametricPattern {
    // Extract parameters from generated code
    const sizeMatch = code.match(/size\s*=\s*(\d+)/)
    const densityMatch = code.match(/density\s*=\s*([\d.]+)/)
    
    return {
      type: patternType as any,
      size: sizeMatch ? parseInt(sizeMatch[1]) : 30,
      density: densityMatch ? parseFloat(densityMatch[1]) : 1.0,
      rotation: 0,
      colors: {
        primary: '#000000',
        secondary: '#ffffff',
        accent: '#ff0000'
      },
      opacity: 1.0
    }
  }
  
  private static extractGrowthParametersFromCode(code: string): Record<string, any> {
    return {
      randomSeed: code.includes('random') ? Math.random() : 0,
      complexity: code.includes('complex') ? 0.8 : 0.5,
      iterations: 10
    }
  }
  
  private static generateGrowthAlgorithmCode(growthData: GrowthData): string {
    return `// Auto-generated ${growthData.algorithm} growth pattern
canvas.background('${growthData.settings.colors.primary}')
draw.fill('${growthData.settings.colors.secondary}')
draw.noStroke()

const growthRate = ${growthData.settings.growthRate}
const density = ${growthData.settings.density}
let generation = ${growthData.generation}

// Growth simulation
for (let i = 0; i < 100; i++) {
  const x = Math.random() * canvas.width
  const y = Math.random() * canvas.height
  
  if (Math.random() < growthRate * density) {
    shapes.circle(x, y, 2)
  }
}`
  }
  
  private static detectGrowthLikeDrawing(drawData: DrawData): boolean {
    // Detect if drawing has growth-like characteristics
    return drawData.strokes.length > 10 && 
           drawData.strokes.some(s => s.points.length > 5)
  }
  
  private static extractGrowthFromDrawing(drawData: DrawData): Record<string, any> {
    return {
      strokeCount: drawData.strokes.length,
      complexity: 0.5,
      organic: true
    }
  }
  
  private static convertStrokesToGrowthPoints(strokes: DrawStroke[]): { x: number; y: number }[] {
    const points: { x: number; y: number }[] = []
    
    for (const stroke of strokes) {
      for (const point of stroke.points) {
        points.push({ x: point.x, y: point.y })
      }
    }
    
    return points
  }
  
  private static mapPatternToGrowthAlgorithm(patternType: string): 'organic' | 'l-system' | 'cellular-automata' | 'reaction-diffusion' {
    switch (patternType) {
      case 'ichimatsu': return 'cellular-automata'
      case 'seigaiha': return 'organic'
      case 'asanoha': return 'l-system'
      case 'shippo': return 'reaction-diffusion'
      case 'yamaji': return 'organic'
      default: return 'organic'
    }
  }
  
  private static generateStrokesFromPattern(pattern: ParametricPattern): DrawStroke[] {
    const strokes: DrawStroke[] = []
    
    // Generate representative strokes for each pattern type
    switch (pattern.type) {
      case 'ichimatsu':
        strokes.push(...this.generateIchimatsuStrokes(pattern))
        break
      case 'seigaiha':
        strokes.push(...this.generateSeigaihaStrokes(pattern))
        break
      case 'asanoha':
        strokes.push(...this.generateAsanohaStrokes(pattern))
        break
      case 'shippo':
        strokes.push(...this.generateShippoStrokes(pattern))
        break
      case 'yamaji':
        strokes.push(...this.generateYamajiStrokes(pattern))
        break
    }
    
    return strokes
  }
  
  private static generateIchimatsuStrokes(pattern: ParametricPattern): DrawStroke[] {
    const strokes: DrawStroke[] = []
    const size = pattern.size
    
    // Generate grid strokes
    for (let i = 0; i < 5; i++) {
      // Horizontal lines
      strokes.push({
        id: `ichimatsu-h-${i}`,
        points: [
          { x: 0, y: i * size },
          { x: size * 5, y: i * size }
        ],
        color: pattern.colors.primary,
        width: 2,
        opacity: pattern.opacity,
        timestamp: Date.now()
      })
      
      // Vertical lines
      strokes.push({
        id: `ichimatsu-v-${i}`,
        points: [
          { x: i * size, y: 0 },
          { x: i * size, y: size * 5 }
        ],
        color: pattern.colors.primary,
        width: 2,
        opacity: pattern.opacity,
        timestamp: Date.now()
      })
    }
    
    return strokes
  }
  
  private static generateSeigaihaStrokes(pattern: ParametricPattern): DrawStroke[] {
    const strokes: DrawStroke[] = []
    const radius = pattern.size
    
    // Generate wave curves
    for (let x = 0; x < 300; x += radius * 2) {
      for (let r = 5; r < radius; r += radius / 3) {
        const points: { x: number; y: number }[] = []
        
        // Generate semicircle points
        for (let angle = 0; angle <= Math.PI; angle += 0.1) {
          points.push({
            x: x + Math.cos(angle) * r,
            y: 100 + Math.sin(angle) * r
          })
        }
        
        strokes.push({
          id: `seigaiha-${x}-${r}`,
          points,
          color: pattern.colors.primary,
          width: 2,
          opacity: pattern.opacity,
          timestamp: Date.now()
        })
      }
    }
    
    return strokes
  }
  
  private static generateAsanohaStrokes(pattern: ParametricPattern): DrawStroke[] {
    const strokes: DrawStroke[] = []
    const size = pattern.size
    
    // Generate hexagonal hemp leaf pattern strokes
    const cx = size
    const cy = size
    const radius = size / 3
    
    // Hexagon outline
    const hexPoints: { x: number; y: number }[] = []
    for (let i = 0; i < 6; i++) {
      const angle = (i * Math.PI) / 3
      hexPoints.push({
        x: cx + Math.cos(angle) * radius,
        y: cy + Math.sin(angle) * radius
      })
    }
    hexPoints.push(hexPoints[0]) // Close the shape
    
    strokes.push({
      id: 'asanoha-hex',
      points: hexPoints,
      color: pattern.colors.primary,
      width: 2,
      opacity: pattern.opacity,
      timestamp: Date.now()
    })
    
    // Internal lines
    strokes.push({
      id: 'asanoha-line1',
      points: [
        { x: cx, y: cy - radius },
        { x: cx, y: cy + radius }
      ],
      color: pattern.colors.primary,
      width: 2,
      opacity: pattern.opacity,
      timestamp: Date.now()
    })
    
    return strokes
  }
  
  private static generateShippoStrokes(pattern: ParametricPattern): DrawStroke[] {
    const strokes: DrawStroke[] = []
    const size = pattern.size
    const radius = size / 2
    
    // Generate overlapping circle strokes
    for (let x = 0; x < 200; x += size) {
      for (let y = 0; y < 200; y += size) {
        const cx = x + size / 2
        const cy = y + size / 2
        
        // Circle outline
        const circlePoints: { x: number; y: number }[] = []
        for (let angle = 0; angle <= Math.PI * 2; angle += 0.1) {
          circlePoints.push({
            x: cx + Math.cos(angle) * radius,
            y: cy + Math.sin(angle) * radius
          })
        }
        
        strokes.push({
          id: `shippo-circle-${x}-${y}`,
          points: circlePoints,
          color: pattern.colors.primary,
          width: 2,
          opacity: pattern.opacity,
          timestamp: Date.now()
        })
      }
    }
    
    return strokes
  }
  
  private static generateYamajiStrokes(pattern: ParametricPattern): DrawStroke[] {
    const strokes: DrawStroke[] = []
    const size = pattern.size
    
    // Generate mountain path diagonal lines
    for (let x = 0; x < 200; x += size) {
      for (let y = 0; y < 200; y += size) {
        // Diagonal lines
        strokes.push({
          id: `yamaji-diag1-${x}-${y}`,
          points: [
            { x, y },
            { x: x + size, y: y + size }
          ],
          color: pattern.colors.primary,
          width: 2,
          opacity: pattern.opacity,
          timestamp: Date.now()
        })
        
        strokes.push({
          id: `yamaji-diag2-${x}-${y}`,
          points: [
            { x: x + size, y },
            { x, y: y + size }
          ],
          color: pattern.colors.primary,
          width: 2,
          opacity: pattern.opacity,
          timestamp: Date.now()
        })
      }
    }
    
    return strokes
  }
}