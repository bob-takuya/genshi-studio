<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Genshi Studio - Parametric Pattern Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            height: 100vh;
            touch-action: none; /* Fixed from manipulation */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.9);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .logo {
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4, #45B7D1);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-fill-color: transparent;
        }

        .pattern-title {
            font-size: 14px;
            opacity: 0.8;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .header-controls {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            -webkit-tap-highlight-color: transparent;
        }

        .header-btn:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }

        /* Main Canvas Area - Fixed duplicate definition */
        .main-canvas-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, rgba(70, 70, 90, 0.3), rgba(20, 20, 30, 0.8));
        }

        .pattern-canvas {
            max-width: 90%;
            max-height: 90%;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            touch-action: none; /* Fixed from pan-x pan-y */
            image-rendering: crisp-edges;
            image-rendering: -webkit-crisp-edges;
        }

        /* Mobile Parameter Panel */
        .params-panel {
            background: rgba(0, 0, 0, 0.95);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            transition: height 0.3s ease;
        }

        .params-header {
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
        }

        .panel-toggle {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .panel-toggle.expanded {
            transform: rotate(180deg);
        }

        .params-content {
            max-height: 40vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 0 20px 20px;
        }

        /* Pattern Type Selector */
        .pattern-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
            margin-bottom: 20px;
        }

        .pattern-btn {
            aspect-ratio: 1;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1.2;
            -webkit-tap-highlight-color: transparent;
        }

        .pattern-btn.active {
            border-color: #4ECDC4;
            background: rgba(78, 205, 196, 0.2);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }

        .pattern-btn:active {
            transform: scale(0.95);
        }

        /* Parameter Controls */
        .param-group {
            margin-bottom: 20px;
        }

        .param-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .param-value {
            color: #4ECDC4;
            font-weight: 600;
            font-size: 12px;
        }

        .param-slider {
            width: 100%;
            height: 44px; /* Touch-optimized */
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
            cursor: pointer;
        }

        .param-slider::-webkit-slider-track {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .param-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #4ECDC4;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .param-slider::-moz-range-track {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .param-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #4ECDC4;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* 2D Control */
        .param-2d {
            width: 100%;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            touch-action: none;
        }

        .param-2d-handle {
            position: absolute;
            width: 28px;
            height: 28px;
            background: #4ECDC4;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }

        /* Color Controls */
        .color-group {
            display: flex;
            gap: 16px;
            justify-content: space-around;
            padding: 12px 0;
        }

        .color-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .color-picker {
            width: 52px;
            height: 52px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            -webkit-appearance: none;
            padding: 0;
            background: none;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .color-label {
            font-size: 10px;
            opacity: 0.8;
        }

        /* Action Buttons */
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 20px;
        }

        .action-btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-primary {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .action-btn:active {
            transform: scale(0.95);
        }

        /* Performance Indicator */
        .perf-indicator {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 500;
            z-index: 10;
            pointer-events: none;
        }

        .fps-good { color: #4ECDC4; }
        .fps-medium { color: #FFE66D; }
        .fps-poor { color: #FF6B6B; }

        /* Error State */
        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 107, 107, 0.9);
            padding: 20px 30px;
            border-radius: 12px;
            text-align: center;
            display: none;
        }

        /* Responsive Design */
        @media (max-width: 480px) {
            .header {
                padding: 8px 16px;
            }
            
            .logo {
                font-size: 16px;
            }
            
            .pattern-title {
                font-size: 12px;
            }
            
            .params-content {
                padding: 0 16px 16px;
            }
            
            .pattern-selector {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (orientation: landscape) and (max-height: 600px) {
            .params-content {
                max-height: 30vh;
            }
        }

        /* Loading Animation */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            opacity: 0.8;
            display: none;
        }

        .loading.active {
            display: block;
        }

        .loading::after {
            content: '';
            animation: loading-dots 1.5s infinite;
        }

        @keyframes loading-dots {
            0%, 20% { content: '●'; }
            40% { content: '●●'; }
            60% { content: '●●●'; }
            80%, 100% { content: '●●●●'; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="logo">Genshi Studio</div>
            <div class="pattern-title" id="patternTitle">Islamic Geometric</div>
            <div class="header-controls">
                <button class="header-btn" onclick="randomizePattern()">🎲</button>
                <button class="header-btn" onclick="exportPattern()">📤</button>
                <button class="header-btn" onclick="toggleFullscreen()">⛶</button>
            </div>
        </header>

        <!-- Canvas Area - Fixed class name -->
        <main class="main-canvas-container">
            <canvas id="patternCanvas" class="pattern-canvas" width="800" height="800"></canvas>
            <div class="perf-indicator">
                <span id="fpsCounter" class="fps-good">60 FPS</span>
            </div>
            <div class="loading" id="loadingIndicator">Generating Pattern</div>
            <div class="error-message" id="errorMessage">
                <h3>Oops! Something went wrong</h3>
                <p>Please refresh the page to try again</p>
            </div>
        </main>

        <!-- Parameter Panel -->
        <section class="params-panel" id="paramsPanel">
            <div class="params-header" onclick="togglePanel()">
                <h2 class="panel-title">Pattern Parameters</h2>
                <button class="panel-toggle" id="panelToggle">▲</button>
            </div>
            
            <div class="params-content" id="paramsContent">
                <!-- Pattern Type Selector -->
                <div class="param-group">
                    <div class="param-label">Pattern Type</div>
                    <div class="pattern-selector">
                        <button class="pattern-btn active" data-pattern="islamic" onclick="selectPattern('islamic')">
                            Islamic<br>Geometric
                        </button>
                        <button class="pattern-btn" data-pattern="penrose" onclick="selectPattern('penrose')">
                            Penrose<br>Tiling
                        </button>
                        <button class="pattern-btn" data-pattern="truchet" onclick="selectPattern('truchet')">
                            Truchet<br>Tiles
                        </button>
                        <button class="pattern-btn" data-pattern="celtic" onclick="selectPattern('celtic')">
                            Celtic<br>Knots
                        </button>
                        <button class="pattern-btn" data-pattern="mandelbrot" onclick="selectPattern('mandelbrot')">
                            Mandelbrot<br>Fractal
                        </button>
                        <button class="pattern-btn" data-pattern="voronoi" onclick="selectPattern('voronoi')">
                            Voronoi<br>Cells
                        </button>
                        <button class="pattern-btn" data-pattern="crystallographic" onclick="selectPattern('crystallographic')">
                            Crystal<br>Lattice
                        </button>
                        <button class="pattern-btn" data-pattern="lsystem" onclick="selectPattern('lsystem')">
                            L-System<br>Fractal
                        </button>
                    </div>
                </div>

                <!-- 2D Parameter Control -->
                <div class="param-group">
                    <div class="param-label">
                        Scale & Rotation
                        <span class="param-value" id="scaleRotValue">1.0, 0°</span>
                    </div>
                    <div class="param-2d" id="scaleRotControl">
                        <div class="param-2d-handle" id="scaleRotHandle"></div>
                    </div>
                </div>

                <!-- Primary Parameters -->
                <div class="param-group">
                    <div class="param-label">
                        Complexity
                        <span class="param-value" id="complexityValue">5</span>
                    </div>
                    <input type="range" class="param-slider" id="complexitySlider" 
                           min="1" max="20" value="5" 
                           oninput="updateParameter('complexity', this.value)">
                </div>

                <div class="param-group">
                    <div class="param-label">
                        Density
                        <span class="param-value" id="densityValue">1.0</span>
                    </div>
                    <input type="range" class="param-slider" id="densitySlider" 
                           min="0.1" max="3.0" step="0.1" value="1.0"
                           oninput="updateParameter('density', this.value)">
                </div>

                <div class="param-group">
                    <div class="param-label">
                        Symmetry
                        <span class="param-value" id="symmetryValue">8</span>
                    </div>
                    <input type="range" class="param-slider" id="symmetrySlider" 
                           min="3" max="24" value="8"
                           oninput="updateParameter('symmetry', this.value)">
                </div>

                <!-- Color Controls -->
                <div class="param-group">
                    <div class="param-label">Colors</div>
                    <div class="color-group">
                        <div class="color-control">
                            <input type="color" class="color-picker" id="primaryColor" 
                                   value="#4ECDC4" onchange="updateColor('primary', this.value)">
                            <span class="color-label">Primary</span>
                        </div>
                        <div class="color-control">
                            <input type="color" class="color-picker" id="secondaryColor" 
                                   value="#FF6B6B" onchange="updateColor('secondary', this.value)">
                            <span class="color-label">Secondary</span>
                        </div>
                        <div class="color-control">
                            <input type="color" class="color-picker" id="accentColor" 
                                   value="#FFE66D" onchange="updateColor('accent', this.value)">
                            <span class="color-label">Accent</span>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="action-btn btn-primary" onclick="generateVariation()">
                        Generate Variation
                    </button>
                    <button class="action-btn btn-secondary" onclick="resetToDefault()">
                        Reset Default
                    </button>
                </div>
            </div>
        </section>
    </div>

    <script>
        // App State
        let appState = {
            currentPattern: 'islamic',
            parameters: {
                complexity: 5,
                density: 1.0,
                symmetry: 8,
                scale: 1.0,
                rotation: 0,
                colors: {
                    primary: '#4ECDC4',
                    secondary: '#FF6B6B',
                    accent: '#FFE66D',
                    background: '#000000'
                }
            },
            performance: {
                fps: 60,
                frameTime: 16.67,
                lastFrameTime: 0,
                frameCount: 0,
                lastFpsUpdate: 0
            },
            ui: {
                panelExpanded: true,
                isDragging: false
            },
            rendering: {
                animationId: null,
                isGenerating: false
            }
        };

        // Canvas and Context with error handling
        let canvas, ctx, loadingIndicator, errorMessage;
        
        // Initialize with error handling
        function initializeApp() {
            try {
                canvas = document.getElementById('patternCanvas');
                ctx = canvas.getContext('2d', { 
                    alpha: false,
                    desynchronized: true 
                });
                
                if (!ctx) {
                    throw new Error('Canvas context not available');
                }
                
                loadingIndicator = document.getElementById('loadingIndicator');
                errorMessage = document.getElementById('errorMessage');
                
                // Set up canvas with proper DPR
                setupCanvas();
                
                // Initialize pattern
                generatePattern();
                
                // Set up 2D control
                setup2DControl();
                
                // Start performance monitoring (throttled)
                startPerformanceMonitoring();
                
            } catch (error) {
                showError('Failed to initialize the application. Please refresh the page.');
                console.error('Initialization error:', error);
            }
        }

        // Canvas setup with proper DPR handling
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            // Set display size
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            // Set actual size in memory
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Scale context to ensure correct drawing operations
            ctx.scale(dpr, dpr);
            
            // Set drawing defaults
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        // Pattern Definitions
        const patterns = {
            islamic: {
                title: 'Islamic Geometric',
                generator: generateIslamicGeometric,
                defaultParams: { complexity: 5, density: 1.0, symmetry: 8 }
            },
            penrose: {
                title: 'Penrose Tiling',
                generator: generatePenroseTiling,
                defaultParams: { complexity: 3, density: 1.2, symmetry: 5 }
            },
            truchet: {
                title: 'Truchet Tiles',
                generator: generateTruchetTiles,
                defaultParams: { complexity: 2, density: 0.8, symmetry: 4 }
            },
            celtic: {
                title: 'Celtic Knots',
                generator: generateCelticKnots,
                defaultParams: { complexity: 4, density: 1.0, symmetry: 6 }
            },
            mandelbrot: {
                title: 'Mandelbrot Fractal',
                generator: generateMandelbrot,
                defaultParams: { complexity: 50, density: 2.0, symmetry: 1 }
            },
            voronoi: {
                title: 'Voronoi Cells',
                generator: generateVoronoi,
                defaultParams: { complexity: 20, density: 1.0, symmetry: 1 }
            },
            crystallographic: {
                title: 'Crystal Lattice',
                generator: generateCrystallographic,
                defaultParams: { complexity: 6, density: 1.0, symmetry: 6 }
            },
            lsystem: {
                title: 'L-System Fractal',
                generator: generateLSystem,
                defaultParams: { complexity: 5, density: 1.0, symmetry: 1 }
            }
        };

        // Pattern Generation with error handling and performance optimization
        async function generatePattern() {
            if (appState.rendering.isGenerating) return;
            
            try {
                appState.rendering.isGenerating = true;
                showLoading(true);
                
                // Use requestAnimationFrame for non-blocking rendering
                await new Promise(resolve => {
                    requestAnimationFrame(() => {
                        const pattern = patterns[appState.currentPattern];
                        if (pattern && pattern.generator) {
                            // Clear canvas
                            const rect = canvas.getBoundingClientRect();
                            ctx.clearRect(0, 0, rect.width, rect.height);
                            
                            // Save context state
                            ctx.save();
                            
                            // Apply transformations
                            ctx.translate(rect.width / 2, rect.height / 2);
                            ctx.scale(appState.parameters.scale, appState.parameters.scale);
                            ctx.rotate(appState.parameters.rotation * Math.PI / 180);
                            
                            // Generate pattern
                            pattern.generator();
                            
                            // Restore context state
                            ctx.restore();
                        }
                        resolve();
                    });
                });
                
            } catch (error) {
                console.error('Pattern generation error:', error);
                showError('Failed to generate pattern. Please try again.');
            } finally {
                appState.rendering.isGenerating = false;
                showLoading(false);
            }
        }

        // Pattern Generators (optimized versions)
        function generateIslamicGeometric() {
            const size = Math.min(canvas.width, canvas.height) / 3;
            const { complexity, symmetry, colors, density } = appState.parameters;
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
            
            // Use path batching for performance
            ctx.beginPath();
            
            for (let ring = 1; ring <= complexity; ring++) {
                const radius = (size * ring / complexity) * density;
                const points = symmetry * ring;
                
                for (let i = 0; i < points; i++) {
                    const angle = (i * 2 * Math.PI) / points;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    
                    // Draw star pattern
                    for (let j = 0; j < 8; j++) {
                        const starAngle = angle + (j * Math.PI / 4);
                        const innerRadius = radius * 0.3;
                        const outerRadius = radius * 0.5;
                        
                        const isOuter = j % 2 === 0;
                        const r = isOuter ? outerRadius : innerRadius;
                        
                        const sx = x + r * Math.cos(starAngle);
                        const sy = y + r * Math.sin(starAngle);
                        
                        if (j === 0) {
                            ctx.moveTo(sx, sy);
                        } else {
                            ctx.lineTo(sx, sy);
                        }
                    }
                    ctx.closePath();
                }
            }
            
            // Apply gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            gradient.addColorStop(0, colors.primary);
            gradient.addColorStop(0.5, colors.secondary);
            gradient.addColorStop(1, colors.accent);
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function generatePenroseTiling() {
            const size = Math.min(canvas.width, canvas.height) / 3;
            const { complexity, colors, density } = appState.parameters;
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
            
            const goldenRatio = (1 + Math.sqrt(5)) / 2;
            
            // Batch path operations
            ctx.beginPath();
            
            for (let i = 0; i < complexity; i++) {
                for (let j = 0; j < 5; j++) {
                    const angle = j * 2 * Math.PI / 5;
                    const distance = i * size / complexity * density;
                    
                    // Kite shape
                    const x = distance * Math.cos(angle);
                    const y = distance * Math.sin(angle);
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    
                    // Draw kite
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size/goldenRatio, 0);
                    ctx.lineTo(size/goldenRatio * Math.cos(Math.PI/5), size/goldenRatio * Math.sin(Math.PI/5));
                    ctx.lineTo(0, size/goldenRatio);
                    ctx.closePath();
                    
                    ctx.restore();
                }
            }
            
            ctx.strokeStyle = colors.primary;
            ctx.fillStyle = `${colors.secondary}33`;
            ctx.lineWidth = 1;
            ctx.fill();
            ctx.stroke();
        }

        function generateTruchetTiles() {
            const { complexity, colors, density } = appState.parameters;
            const tileSize = Math.min(canvas.width, canvas.height) / (complexity * 3) * density;
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
            
            const rows = Math.ceil(canvas.height / tileSize);
            const cols = Math.ceil(canvas.width / tileSize);
            
            for (let row = -rows/2; row < rows/2; row++) {
                for (let col = -cols/2; col < cols/2; col++) {
                    const x = col * tileSize;
                    const y = row * tileSize;
                    const rotation = Math.random() < 0.5 ? 0 : Math.PI / 2;
                    
                    ctx.save();
                    ctx.translate(x + tileSize/2, y + tileSize/2);
                    ctx.rotate(rotation);
                    
                    ctx.beginPath();
                    ctx.arc(-tileSize/2, -tileSize/2, tileSize/2, 0, Math.PI/2);
                    ctx.arc(tileSize/2, tileSize/2, tileSize/2, Math.PI, Math.PI * 3/2);
                    
                    ctx.strokeStyle = colors.primary;
                    ctx.lineWidth = tileSize / 10;
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
        }

        function generateCelticKnots() {
            const size = Math.min(canvas.width, canvas.height) / 3;
            const { complexity, symmetry, colors, density } = appState.parameters;
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
            
            const knotRadius = size * density;
            const strands = symmetry;
            
            // Draw interlaced strands
            for (let strand = 0; strand < strands; strand++) {
                ctx.beginPath();
                
                for (let t = 0; t <= complexity * Math.PI * 2; t += 0.1) {
                    const angle = t + (strand * 2 * Math.PI / strands);
                    const r = knotRadius * (1 + 0.3 * Math.sin(complexity * t));
                    
                    const x = r * Math.cos(angle);
                    const y = r * Math.sin(angle);
                    
                    if (t === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                const gradient = ctx.createLinearGradient(-size, -size, size, size);
                gradient.addColorStop(0, colors.primary);
                gradient.addColorStop(0.5, colors.secondary);
                gradient.addColorStop(1, colors.accent);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = size / 20;
                ctx.stroke();
            }
        }

        function generateMandelbrot() {
            const { complexity, colors, density, scale } = appState.parameters;
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            const zoom = 200 / density;
            const offsetX = width / 2;
            const offsetY = height / 2;
            
            // Optimized Mandelbrot calculation
            for (let x = 0; x < width; x += 2) { // Skip pixels for performance
                for (let y = 0; y < height; y += 2) {
                    const c_re = (x - offsetX) / zoom - 0.5;
                    const c_im = (y - offsetY) / zoom;
                    
                    let z_re = 0;
                    let z_im = 0;
                    let iteration = 0;
                    
                    while (z_re * z_re + z_im * z_im <= 4 && iteration < complexity) {
                        const tmp = z_re * z_re - z_im * z_im + c_re;
                        z_im = 2 * z_re * z_im + c_im;
                        z_re = tmp;
                        iteration++;
                    }
                    
                    const color = iteration === complexity ? 0 : (iteration * 255 / complexity);
                    const idx = (y * width + x) * 4;
                    
                    // Set pixel colors
                    data[idx] = color * parseInt(colors.primary.slice(1, 3), 16) / 255;
                    data[idx + 1] = color * parseInt(colors.secondary.slice(3, 5), 16) / 255;
                    data[idx + 2] = color * parseInt(colors.accent.slice(5, 7), 16) / 255;
                    data[idx + 3] = 255;
                    
                    // Fill skipped pixels
                    if (x < width - 1 && y < height - 1) {
                        for (let dx = 0; dx < 2; dx++) {
                            for (let dy = 0; dy < 2; dy++) {
                                const fillIdx = ((y + dy) * width + (x + dx)) * 4;
                                data[fillIdx] = data[idx];
                                data[fillIdx + 1] = data[idx + 1];
                                data[fillIdx + 2] = data[idx + 2];
                                data[fillIdx + 3] = 255;
                            }
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, -width/2, -height/2);
        }

        function generateVoronoi() {
            const { complexity, colors, density } = appState.parameters;
            const numPoints = complexity * 3;
            const points = [];
            
            // Generate random points
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: (Math.random() - 0.5) * canvas.width,
                    y: (Math.random() - 0.5) * canvas.height,
                    color: i % 3 === 0 ? colors.primary : (i % 3 === 1 ? colors.secondary : colors.accent)
                });
            }
            
            // Draw Voronoi cells
            const cellSize = Math.min(canvas.width, canvas.height) / (complexity * density);
            
            for (let x = -canvas.width/2; x < canvas.width/2; x += cellSize) {
                for (let y = -canvas.height/2; y < canvas.height/2; y += cellSize) {
                    let minDist = Infinity;
                    let nearestPoint = null;
                    
                    for (const point of points) {
                        const dist = Math.hypot(x - point.x, y - point.y);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestPoint = point;
                        }
                    }
                    
                    if (nearestPoint) {
                        ctx.fillStyle = nearestPoint.color + '33';
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                }
            }
            
            // Draw points
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = point.color;
                ctx.fill();
            });
        }

        function generateCrystallographic() {
            const { complexity, symmetry, colors, density } = appState.parameters;
            const size = Math.min(canvas.width, canvas.height) / (complexity * 2);
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
            
            // Hexagonal lattice
            const a = size * density;
            const b = a * Math.sqrt(3) / 2;
            
            for (let i = -complexity; i <= complexity; i++) {
                for (let j = -complexity; j <= complexity; j++) {
                    const x = i * a * 1.5;
                    const y = j * b * 2 + (i % 2) * b;
                    
                    // Draw hexagon
                    ctx.beginPath();
                    for (let k = 0; k < 6; k++) {
                        const angle = k * Math.PI / 3;
                        const hx = x + a * Math.cos(angle);
                        const hy = y + a * Math.sin(angle);
                        
                        if (k === 0) {
                            ctx.moveTo(hx, hy);
                        } else {
                            ctx.lineTo(hx, hy);
                        }
                    }
                    ctx.closePath();
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, a);
                    gradient.addColorStop(0, colors.primary + '66');
                    gradient.addColorStop(1, colors.secondary + '33');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    ctx.strokeStyle = colors.accent;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        function generateLSystem() {
            const { complexity, colors, density } = appState.parameters;
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
            
            // L-System rules for a fractal tree
            let axiom = 'F';
            const rules = { 'F': 'FF+[+F-F-F]-[-F+F+F]' };
            
            // Generate string
            let current = axiom;
            for (let i = 0; i < complexity; i++) {
                let next = '';
                for (const char of current) {
                    next += rules[char] || char;
                }
                current = next;
            }
            
            // Draw L-System
            ctx.beginPath();
            ctx.moveTo(0, canvas.height/4);
            
            const stack = [];
            let angle = -Math.PI / 2;
            const angleIncrement = Math.PI / 6;
            const stepSize = Math.min(canvas.width, canvas.height) / (Math.pow(2, complexity) * 5) * density;
            
            for (const char of current) {
                switch (char) {
                    case 'F':
                        ctx.lineTo(
                            ctx.currentX + stepSize * Math.cos(angle),
                            ctx.currentY + stepSize * Math.sin(angle)
                        );
                        break;
                    case '+':
                        angle += angleIncrement;
                        break;
                    case '-':
                        angle -= angleIncrement;
                        break;
                    case '[':
                        stack.push({ x: ctx.currentX, y: ctx.currentY, angle });
                        break;
                    case ']':
                        const state = stack.pop();
                        if (state) {
                            ctx.moveTo(state.x, state.y);
                            angle = state.angle;
                        }
                        break;
                }
            }
            
            const gradient = ctx.createLinearGradient(0, -canvas.height/2, 0, canvas.height/2);
            gradient.addColorStop(0, colors.primary);
            gradient.addColorStop(0.5, colors.secondary);
            gradient.addColorStop(1, colors.accent);
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = Math.max(1, 5 - complexity);
            ctx.stroke();
        }

        // UI Functions
        function selectPattern(patternType) {
            if (patterns[patternType]) {
                // Update active button
                document.querySelectorAll('.pattern-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.pattern === patternType);
                });
                
                // Update state
                appState.currentPattern = patternType;
                
                // Update title
                document.getElementById('patternTitle').textContent = patterns[patternType].title;
                
                // Apply default parameters
                const defaults = patterns[patternType].defaultParams;
                Object.assign(appState.parameters, defaults);
                
                // Update UI
                updateUIValues();
                
                // Generate new pattern
                generatePattern();
            }
        }

        function updateParameter(param, value) {
            appState.parameters[param] = parseFloat(value);
            document.getElementById(`${param}Value`).textContent = 
                param === 'density' ? parseFloat(value).toFixed(1) : value;
            
            // Debounce pattern generation
            clearTimeout(appState.rendering.updateTimeout);
            appState.rendering.updateTimeout = setTimeout(() => generatePattern(), 100);
        }

        function updateColor(colorType, value) {
            appState.parameters.colors[colorType] = value;
            generatePattern();
        }

        function updateUIValues() {
            const { complexity, density, symmetry } = appState.parameters;
            
            document.getElementById('complexitySlider').value = complexity;
            document.getElementById('complexityValue').textContent = complexity;
            
            document.getElementById('densitySlider').value = density;
            document.getElementById('densityValue').textContent = density.toFixed(1);
            
            document.getElementById('symmetrySlider').value = symmetry;
            document.getElementById('symmetryValue').textContent = symmetry;
        }

        function randomizePattern() {
            const patternKeys = Object.keys(patterns);
            const randomPattern = patternKeys[Math.floor(Math.random() * patternKeys.length)];
            selectPattern(randomPattern);
            
            // Randomize parameters within reasonable bounds
            appState.parameters.complexity = Math.floor(Math.random() * 10) + 3;
            appState.parameters.density = Math.random() * 1.5 + 0.5;
            appState.parameters.symmetry = Math.floor(Math.random() * 12) + 3;
            
            // Randomize colors
            appState.parameters.colors.primary = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            appState.parameters.colors.secondary = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            appState.parameters.colors.accent = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            
            updateUIValues();
            updateColorPickers();
            generatePattern();
        }

        function generateVariation() {
            // Slightly modify current parameters
            appState.parameters.complexity = Math.max(1, Math.min(20, 
                appState.parameters.complexity + Math.floor(Math.random() * 5 - 2)));
            appState.parameters.density = Math.max(0.1, Math.min(3.0, 
                appState.parameters.density + (Math.random() * 0.4 - 0.2)));
            appState.parameters.symmetry = Math.max(3, Math.min(24, 
                appState.parameters.symmetry + Math.floor(Math.random() * 5 - 2)));
            
            updateUIValues();
            generatePattern();
        }

        function resetToDefault() {
            const defaults = patterns[appState.currentPattern].defaultParams;
            Object.assign(appState.parameters, defaults);
            
            // Reset colors
            appState.parameters.colors = {
                primary: '#4ECDC4',
                secondary: '#FF6B6B',
                accent: '#FFE66D',
                background: '#000000'
            };
            
            // Reset scale and rotation
            appState.parameters.scale = 1.0;
            appState.parameters.rotation = 0;
            
            updateUIValues();
            updateColorPickers();
            update2DControl();
            generatePattern();
        }

        function updateColorPickers() {
            document.getElementById('primaryColor').value = appState.parameters.colors.primary;
            document.getElementById('secondaryColor').value = appState.parameters.colors.secondary;
            document.getElementById('accentColor').value = appState.parameters.colors.accent;
        }

        function exportPattern() {
            const link = document.createElement('a');
            link.download = `genshi-pattern-${appState.currentPattern}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function togglePanel() {
            appState.ui.panelExpanded = !appState.ui.panelExpanded;
            const panel = document.getElementById('paramsPanel');
            const toggle = document.getElementById('panelToggle');
            const content = document.getElementById('paramsContent');
            
            if (appState.ui.panelExpanded) {
                content.style.display = 'block';
                toggle.classList.add('expanded');
                panel.style.height = 'auto';
            } else {
                content.style.display = 'none';
                toggle.classList.remove('expanded');
                panel.style.height = '60px';
            }
        }

        // 2D Control Setup
        function setup2DControl() {
            const control = document.getElementById('scaleRotControl');
            const handle = document.getElementById('scaleRotHandle');
            
            if (!control || !handle) return;
            
            const updateFromPosition = (clientX, clientY) => {
                const rect = control.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const x = clientX - rect.left - centerX;
                const y = clientY - rect.top - centerY;
                
                // Calculate scale (distance from center)
                const maxDist = Math.min(centerX, centerY);
                const dist = Math.min(Math.hypot(x, y), maxDist);
                const scale = 0.5 + (dist / maxDist) * 2.5;
                
                // Calculate rotation
                const rotation = Math.atan2(y, x) * 180 / Math.PI;
                
                // Update state
                appState.parameters.scale = scale;
                appState.parameters.rotation = rotation;
                
                // Update UI
                handle.style.left = `${centerX + x}px`;
                handle.style.top = `${centerY + y}px`;
                
                document.getElementById('scaleRotValue').textContent = 
                    `${scale.toFixed(1)}, ${Math.round(rotation)}°`;
                
                generatePattern();
            };
            
            // Mouse events
            control.addEventListener('mousedown', (e) => {
                appState.ui.isDragging = true;
                updateFromPosition(e.clientX, e.clientY);
            });
            
            window.addEventListener('mousemove', (e) => {
                if (appState.ui.isDragging) {
                    updateFromPosition(e.clientX, e.clientY);
                }
            });
            
            window.addEventListener('mouseup', () => {
                appState.ui.isDragging = false;
            });
            
            // Touch events
            control.addEventListener('touchstart', (e) => {
                e.preventDefault();
                appState.ui.isDragging = true;
                const touch = e.touches[0];
                updateFromPosition(touch.clientX, touch.clientY);
            });
            
            control.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (appState.ui.isDragging && e.touches.length > 0) {
                    const touch = e.touches[0];
                    updateFromPosition(touch.clientX, touch.clientY);
                }
            });
            
            control.addEventListener('touchend', (e) => {
                e.preventDefault();
                appState.ui.isDragging = false;
            });
        }

        function update2DControl() {
            const control = document.getElementById('scaleRotControl');
            const handle = document.getElementById('scaleRotHandle');
            
            if (!control || !handle) return;
            
            const rect = control.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const { scale, rotation } = appState.parameters;
            const maxDist = Math.min(centerX, centerY);
            const dist = ((scale - 0.5) / 2.5) * maxDist;
            
            const x = dist * Math.cos(rotation * Math.PI / 180);
            const y = dist * Math.sin(rotation * Math.PI / 180);
            
            handle.style.left = `${centerX + x}px`;
            handle.style.top = `${centerY + y}px`;
            
            document.getElementById('scaleRotValue').textContent = 
                `${scale.toFixed(1)}, ${Math.round(rotation)}°`;
        }

        // Performance Monitoring (throttled)
        function startPerformanceMonitoring() {
            let lastTime = performance.now();
            
            function updateFPS() {
                const currentTime = performance.now();
                const deltaTime = currentTime - lastTime;
                
                // Only update FPS display every 500ms
                if (currentTime - appState.performance.lastFpsUpdate > 500) {
                    const fps = Math.round(1000 / deltaTime);
                    const fpsCounter = document.getElementById('fpsCounter');
                    
                    if (fpsCounter) {
                        fpsCounter.textContent = `${fps} FPS`;
                        fpsCounter.className = fps >= 50 ? 'fps-good' : 
                                             fps >= 30 ? 'fps-medium' : 'fps-poor';
                    }
                    
                    appState.performance.lastFpsUpdate = currentTime;
                }
                
                lastTime = currentTime;
                requestAnimationFrame(updateFPS);
            }
            
            requestAnimationFrame(updateFPS);
        }

        // Helper functions
        function showLoading(show) {
            if (loadingIndicator) {
                loadingIndicator.classList.toggle('active', show);
            }
        }

        function showError(message) {
            if (errorMessage) {
                errorMessage.style.display = 'block';
                errorMessage.querySelector('p').textContent = message;
            }
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            clearTimeout(appState.rendering.resizeTimeout);
            appState.rendering.resizeTimeout = setTimeout(() => {
                setupCanvas();
                generatePattern();
            }, 250);
        });

        // Initialize on load
        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>